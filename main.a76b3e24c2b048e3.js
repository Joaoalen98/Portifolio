"use strict"; (self.webpackChunkportifolio = self.webpackChunkportifolio || []).push([[179], { 778: () => { function Y(e) { return "function" == typeof e } function qr(e) { const n = e(r => { Error.call(r), r.stack = (new Error).stack }); return n.prototype = Object.create(Error.prototype), n.prototype.constructor = n, n } const li = qr(e => function (n) { e(this), this.message = n ? `${n.length} errors occurred during unsubscription:\n${n.map((r, o) => `${o + 1}) ${r.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = n }); function Kr(e, t) { if (e) { const n = e.indexOf(t); 0 <= n && e.splice(n, 1) } } class ot { constructor(t) { this.initialTeardown = t, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let t; if (!this.closed) { this.closed = !0; const { _parentage: n } = this; if (n) if (this._parentage = null, Array.isArray(n)) for (const i of n) i.remove(this); else n.remove(this); const { initialTeardown: r } = this; if (Y(r)) try { r() } catch (i) { t = i instanceof li ? i.errors : [i] } const { _finalizers: o } = this; if (o) { this._finalizers = null; for (const i of o) try { Td(i) } catch (s) { t = t ?? [], s instanceof li ? t = [...t, ...s.errors] : t.push(s) } } if (t) throw new li(t) } } add(t) { var n; if (t && t !== this) if (this.closed) Td(t); else { if (t instanceof ot) { if (t.closed || t._hasParent(this)) return; t._addParent(this) } (this._finalizers = null !== (n = this._finalizers) && void 0 !== n ? n : []).push(t) } } _hasParent(t) { const { _parentage: n } = this; return n === t || Array.isArray(n) && n.includes(t) } _addParent(t) { const { _parentage: n } = this; this._parentage = Array.isArray(n) ? (n.push(t), n) : n ? [n, t] : t } _removeParent(t) { const { _parentage: n } = this; n === t ? this._parentage = null : Array.isArray(n) && Kr(n, t) } remove(t) { const { _finalizers: n } = this; n && Kr(n, t), t instanceof ot && t._removeParent(this) } } ot.EMPTY = (() => { const e = new ot; return e.closed = !0, e })(); const Sd = ot.EMPTY; function Md(e) { return e instanceof ot || e && "closed" in e && Y(e.remove) && Y(e.add) && Y(e.unsubscribe) } function Td(e) { Y(e) ? e() : e.unsubscribe() } const Sn = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 }, ci = { setTimeout(e, t, ...n) { const { delegate: r } = ci; return r?.setTimeout ? r.setTimeout(e, t, ...n) : setTimeout(e, t, ...n) }, clearTimeout(e) { const { delegate: t } = ci; return (t?.clearTimeout || clearTimeout)(e) }, delegate: void 0 }; function Ad(e) { ci.setTimeout(() => { const { onUnhandledError: t } = Sn; if (!t) throw e; t(e) }) } function xd() { } const ow = ha("C", void 0, void 0); function ha(e, t, n) { return { kind: e, value: t, error: n } } let Mn = null; function di(e) { if (Sn.useDeprecatedSynchronousErrorHandling) { const t = !Mn; if (t && (Mn = { errorThrown: !1, error: null }), e(), t) { const { errorThrown: n, error: r } = Mn; if (Mn = null, n) throw r } } else e() } class pa extends ot { constructor(t) { super(), this.isStopped = !1, t ? (this.destination = t, Md(t) && t.add(this)) : this.destination = dw } static create(t, n, r) { return new Qr(t, n, r) } next(t) { this.isStopped ? ma(function sw(e) { return ha("N", e, void 0) }(t), this) : this._next(t) } error(t) { this.isStopped ? ma(function iw(e) { return ha("E", void 0, e) }(t), this) : (this.isStopped = !0, this._error(t)) } complete() { this.isStopped ? ma(ow, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(t) { this.destination.next(t) } _error(t) { try { this.destination.error(t) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const uw = Function.prototype.bind; function ga(e, t) { return uw.call(e, t) } class lw { constructor(t) { this.partialObserver = t } next(t) { const { partialObserver: n } = this; if (n.next) try { n.next(t) } catch (r) { fi(r) } } error(t) { const { partialObserver: n } = this; if (n.error) try { n.error(t) } catch (r) { fi(r) } else fi(t) } complete() { const { partialObserver: t } = this; if (t.complete) try { t.complete() } catch (n) { fi(n) } } } class Qr extends pa { constructor(t, n, r) { let o; if (super(), Y(t) || !t) o = { next: t ?? void 0, error: n ?? void 0, complete: r ?? void 0 }; else { let i; this && Sn.useDeprecatedNextContext ? (i = Object.create(t), i.unsubscribe = () => this.unsubscribe(), o = { next: t.next && ga(t.next, i), error: t.error && ga(t.error, i), complete: t.complete && ga(t.complete, i) }) : o = t } this.destination = new lw(o) } } function fi(e) { Sn.useDeprecatedSynchronousErrorHandling ? function aw(e) { Sn.useDeprecatedSynchronousErrorHandling && Mn && (Mn.errorThrown = !0, Mn.error = e) }(e) : Ad(e) } function ma(e, t) { const { onStoppedNotification: n } = Sn; n && ci.setTimeout(() => n(e, t)) } const dw = { closed: !0, next: xd, error: function cw(e) { throw e }, complete: xd }, ya = "function" == typeof Symbol && Symbol.observable || "@@observable"; function Tn(e) { return e } function Rd(e) { return 0 === e.length ? Tn : 1 === e.length ? e[0] : function (n) { return e.reduce((r, o) => o(r), n) } } let de = (() => { class e { constructor(n) { n && (this._subscribe = n) } lift(n) { const r = new e; return r.source = this, r.operator = n, r } subscribe(n, r, o) { const i = function pw(e) { return e && e instanceof pa || function hw(e) { return e && Y(e.next) && Y(e.error) && Y(e.complete) }(e) && Md(e) }(n) ? n : new Qr(n, r, o); return di(() => { const { operator: s, source: a } = this; i.add(s ? s.call(i, a) : a ? this._subscribe(i) : this._trySubscribe(i)) }), i } _trySubscribe(n) { try { return this._subscribe(n) } catch (r) { n.error(r) } } forEach(n, r) { return new (r = Nd(r))((o, i) => { const s = new Qr({ next: a => { try { n(a) } catch (u) { i(u), s.unsubscribe() } }, error: i, complete: o }); this.subscribe(s) }) } _subscribe(n) { var r; return null === (r = this.source) || void 0 === r ? void 0 : r.subscribe(n) } [ya]() { return this } pipe(...n) { return Rd(n)(this) } toPromise(n) { return new (n = Nd(n))((r, o) => { let i; this.subscribe(s => i = s, s => o(s), () => r(i)) }) } } return e.create = t => new e(t), e })(); function Nd(e) { var t; return null !== (t = e ?? Sn.Promise) && void 0 !== t ? t : Promise } const gw = qr(e => function () { e(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); let At = (() => { class e extends de { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(n) { const r = new Pd(this, this); return r.operator = n, r } _throwIfClosed() { if (this.closed) throw new gw } next(n) { di(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (const r of this.currentObservers) r.next(n) } }) } error(n) { di(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = n; const { observers: r } = this; for (; r.length;)r.shift().error(n) } }) } complete() { di(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: n } = this; for (; n.length;)n.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var n; return (null === (n = this.observers) || void 0 === n ? void 0 : n.length) > 0 } _trySubscribe(n) { return this._throwIfClosed(), super._trySubscribe(n) } _subscribe(n) { return this._throwIfClosed(), this._checkFinalizedStatuses(n), this._innerSubscribe(n) } _innerSubscribe(n) { const { hasError: r, isStopped: o, observers: i } = this; return r || o ? Sd : (this.currentObservers = null, i.push(n), new ot(() => { this.currentObservers = null, Kr(i, n) })) } _checkFinalizedStatuses(n) { const { hasError: r, thrownError: o, isStopped: i } = this; r ? n.error(o) : i && n.complete() } asObservable() { const n = new de; return n.source = this, n } } return e.create = (t, n) => new Pd(t, n), e })(); class Pd extends At { constructor(t, n) { super(), this.destination = t, this.source = n } next(t) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.next) || void 0 === r || r.call(n, t) } error(t) { var n, r; null === (r = null === (n = this.destination) || void 0 === n ? void 0 : n.error) || void 0 === r || r.call(n, t) } complete() { var t, n; null === (n = null === (t = this.destination) || void 0 === t ? void 0 : t.complete) || void 0 === n || n.call(t) } _subscribe(t) { var n, r; return null !== (r = null === (n = this.source) || void 0 === n ? void 0 : n.subscribe(t)) && void 0 !== r ? r : Sd } } function Od(e) { return Y(e?.lift) } function be(e) { return t => { if (Od(t)) return t.lift(function (n) { try { return e(n, this) } catch (r) { this.error(r) } }); throw new TypeError("Unable to lift unknown Observable type") } } function Ie(e, t, n, r, o) { return new mw(e, t, n, r, o) } class mw extends pa { constructor(t, n, r, o, i, s) { super(t), this.onFinalize = i, this.shouldUnsubscribe = s, this._next = n ? function (a) { try { n(a) } catch (u) { t.error(u) } } : super._next, this._error = o ? function (a) { try { o(a) } catch (u) { t.error(u) } finally { this.unsubscribe() } } : super._error, this._complete = r ? function () { try { r() } catch (a) { t.error(a) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var t; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: n } = this; super.unsubscribe(), !n && (null === (t = this.onFinalize) || void 0 === t || t.call(this)) } } } function B(e, t) { return be((n, r) => { let o = 0; n.subscribe(Ie(r, i => { r.next(e.call(t, i, o++)) })) }) } function An(e) { return this instanceof An ? (this.v = e, this) : new An(e) } function Dw(e, t, n) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var o, r = n.apply(e, t || []), i = []; return o = {}, s("next"), s("throw"), s("return"), o[Symbol.asyncIterator] = function () { return this }, o; function s(f) { r[f] && (o[f] = function (h) { return new Promise(function (p, g) { i.push([f, h, p, g]) > 1 || a(f, h) }) }) } function a(f, h) { try { !function u(f) { f.value instanceof An ? Promise.resolve(f.value.v).then(l, c) : d(i[0][2], f) }(r[f](h)) } catch (p) { d(i[0][3], p) } } function l(f) { a("next", f) } function c(f) { a("throw", f) } function d(f, h) { f(h), i.shift(), i.length && a(i[0][0], i[0][1]) } } function ww(e) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var n, t = e[Symbol.asyncIterator]; return t ? t.call(e) : (e = function Ld(e) { var t = "function" == typeof Symbol && Symbol.iterator, n = t && e[t], r = 0; if (n) return n.call(e); if (e && "number" == typeof e.length) return { next: function () { return e && r >= e.length && (e = void 0), { value: e && e[r++], done: !e } } }; throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.") }(e), n = {}, r("next"), r("throw"), r("return"), n[Symbol.asyncIterator] = function () { return this }, n); function r(i) { n[i] = e[i] && function (s) { return new Promise(function (a, u) { !function o(i, s, a, u) { Promise.resolve(u).then(function (l) { i({ value: l, done: a }) }, s) }(a, u, (s = e[i](s)).done, s.value) }) } } } const jd = e => e && "number" == typeof e.length && "function" != typeof e; function Vd(e) { return Y(e?.then) } function $d(e) { return Y(e[ya]) } function Hd(e) { return Symbol.asyncIterator && Y(e?.[Symbol.asyncIterator]) } function Bd(e) { return new TypeError(`You provided ${null !== e && "object" == typeof e ? "an invalid object" : `'${e}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } const Ud = function _w() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }(); function zd(e) { return Y(e?.[Ud]) } function Gd(e) { return Dw(this, arguments, function* () { const n = e.getReader(); try { for (; ;) { const { value: r, done: o } = yield An(n.read()); if (o) return yield An(void 0); yield yield An(r) } } finally { n.releaseLock() } }) } function Wd(e) { return Y(e?.getReader) } function xt(e) { if (e instanceof de) return e; if (null != e) { if ($d(e)) return function Ew(e) { return new de(t => { const n = e[ya](); if (Y(n.subscribe)) return n.subscribe(t); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(e); if (jd(e)) return function bw(e) { return new de(t => { for (let n = 0; n < e.length && !t.closed; n++)t.next(e[n]); t.complete() }) }(e); if (Vd(e)) return function Iw(e) { return new de(t => { e.then(n => { t.closed || (t.next(n), t.complete()) }, n => t.error(n)).then(null, Ad) }) }(e); if (Hd(e)) return qd(e); if (zd(e)) return function Sw(e) { return new de(t => { for (const n of e) if (t.next(n), t.closed) return; t.complete() }) }(e); if (Wd(e)) return function Mw(e) { return qd(Gd(e)) }(e) } throw Bd(e) } function qd(e) { return new de(t => { (function Tw(e, t) { var n, r, o, i; return function yw(e, t, n, r) { return new (n || (n = Promise))(function (i, s) { function a(c) { try { l(r.next(c)) } catch (d) { s(d) } } function u(c) { try { l(r.throw(c)) } catch (d) { s(d) } } function l(c) { c.done ? i(c.value) : function o(i) { return i instanceof n ? i : new n(function (s) { s(i) }) }(c.value).then(a, u) } l((r = r.apply(e, t || [])).next()) }) }(this, void 0, void 0, function* () { try { for (n = ww(e); !(r = yield n.next()).done;)if (t.next(r.value), t.closed) return } catch (s) { o = { error: s } } finally { try { r && !r.done && (i = n.return) && (yield i.call(n)) } finally { if (o) throw o.error } } t.complete() }) })(e, t).catch(n => t.error(n)) }) } function Ht(e, t, n, r = 0, o = !1) { const i = t.schedule(function () { n(), o ? e.add(this.schedule(null, r)) : this.unsubscribe() }, r); if (e.add(i), !o) return i } function Me(e, t, n = 1 / 0) { return Y(t) ? Me((r, o) => B((i, s) => t(r, i, o, s))(xt(e(r, o))), n) : ("number" == typeof t && (n = t), be((r, o) => function Aw(e, t, n, r, o, i, s, a) { const u = []; let l = 0, c = 0, d = !1; const f = () => { d && !u.length && !l && t.complete() }, h = g => l < r ? p(g) : u.push(g), p = g => { i && t.next(g), l++; let y = !1; xt(n(g, c++)).subscribe(Ie(t, D => { o?.(D), i ? h(D) : t.next(D) }, () => { y = !0 }, void 0, () => { if (y) try { for (l--; u.length && l < r;) { const D = u.shift(); s ? Ht(t, s, () => p(D)) : p(D) } f() } catch (D) { t.error(D) } })) }; return e.subscribe(Ie(t, h, () => { d = !0, f() })), () => { a?.() } }(r, o, e, n))) } function Yn(e = 1 / 0) { return Me(Tn, e) } const Bt = new de(e => e.complete()); function Da(e) { return e[e.length - 1] } function Zr(e) { return function Rw(e) { return e && Y(e.schedule) }(Da(e)) ? e.pop() : void 0 } function Kd(e, t = 0) { return be((n, r) => { n.subscribe(Ie(r, o => Ht(r, e, () => r.next(o), t), () => Ht(r, e, () => r.complete(), t), o => Ht(r, e, () => r.error(o), t))) }) } function Qd(e, t = 0) { return be((n, r) => { r.add(e.schedule(() => n.subscribe(r), t)) }) } function Zd(e, t) { if (!e) throw new Error("Iterable cannot be null"); return new de(n => { Ht(n, t, () => { const r = e[Symbol.asyncIterator](); Ht(n, t, () => { r.next().then(o => { o.done ? n.complete() : n.next(o.value) }) }, 0, !0) }) }) } function ve(e, t) { return t ? function Vw(e, t) { if (null != e) { if ($d(e)) return function Ow(e, t) { return xt(e).pipe(Qd(t), Kd(t)) }(e, t); if (jd(e)) return function kw(e, t) { return new de(n => { let r = 0; return t.schedule(function () { r === e.length ? n.complete() : (n.next(e[r++]), n.closed || this.schedule()) }) }) }(e, t); if (Vd(e)) return function Fw(e, t) { return xt(e).pipe(Qd(t), Kd(t)) }(e, t); if (Hd(e)) return Zd(e, t); if (zd(e)) return function Lw(e, t) { return new de(n => { let r; return Ht(n, t, () => { r = e[Ud](), Ht(n, t, () => { let o, i; try { ({ value: o, done: i } = r.next()) } catch (s) { return void n.error(s) } i ? n.complete() : n.next(o) }, 0, !0) }), () => Y(r?.return) && r.return() }) }(e, t); if (Wd(e)) return function jw(e, t) { return Zd(Gd(e), t) }(e, t) } throw Bd(e) }(e, t) : xt(e) } function wa(e, t, ...n) { if (!0 === t) return void e(); if (!1 === t) return; const r = new Qr({ next: () => { r.unsubscribe(), e() } }); return t(...n).subscribe(r) } function Z(e) { for (let t in e) if (e[t] === Z) return t; throw Error("Could not find renamed property on target object.") } function J(e) { if ("string" == typeof e) return e; if (Array.isArray(e)) return "[" + e.map(J).join(", ") + "]"; if (null == e) return "" + e; if (e.overriddenName) return `${e.overriddenName}`; if (e.name) return `${e.name}`; const t = e.toString(); if (null == t) return "" + t; const n = t.indexOf("\n"); return -1 === n ? t : t.substring(0, n) } function _a(e, t) { return null == e || "" === e ? null === t ? "" : t : null == t || "" === t ? e : e + " " + t } const Bw = Z({ __forward_ref__: Z }); function Ea(e) { return e.__forward_ref__ = Ea, e.toString = function () { return J(this()) }, e } function R(e) { return function ba(e) { return "function" == typeof e && e.hasOwnProperty(Bw) && e.__forward_ref__ === Ea }(e) ? e() : e } class E extends Error { constructor(t, n) { super(function hi(e, t) { return `NG0${Math.abs(e)}${t ? ": " + t.trim() : ""}` }(t, n)), this.code = t } } function F(e) { return "string" == typeof e ? e : null == e ? "" : String(e) } function pi(e, t) { throw new E(-201, !1) } function Je(e, t) { null == e && function K(e, t, n, r) { throw new Error(`ASSERTION ERROR: ${e}` + (null == r ? "" : ` [Expected=> ${n} ${r} ${t} <=Actual]`)) }(t, e, null, "!=") } function N(e) { return { token: e.token, providedIn: e.providedIn || null, factory: e.factory, value: void 0 } } function Rt(e) { return { providers: e.providers || [], imports: e.imports || [] } } function gi(e) { return Jd(e, mi) || Jd(e, Xd) } function Jd(e, t) { return e.hasOwnProperty(t) ? e[t] : null } function Yd(e) { return e && (e.hasOwnProperty(Ia) || e.hasOwnProperty(Jw)) ? e[Ia] : null } const mi = Z({ \u0275prov: Z }), Ia = Z({ \u0275inj: Z }), Xd = Z({ ngInjectableDef: Z }), Jw = Z({ ngInjectorDef: Z }); var A = (() => ((A = A || {})[A.Default = 0] = "Default", A[A.Host = 1] = "Host", A[A.Self = 2] = "Self", A[A.SkipSelf = 4] = "SkipSelf", A[A.Optional = 8] = "Optional", A))(); let Sa; function it(e) { const t = Sa; return Sa = e, t } function ef(e, t, n) { const r = gi(e); return r && "root" == r.providedIn ? void 0 === r.value ? r.value = r.factory() : r.value : n & A.Optional ? null : void 0 !== t ? t : void pi(J(e)) } function ln(e) { return { toString: e }.toString() } var gt = (() => ((gt = gt || {})[gt.OnPush = 0] = "OnPush", gt[gt.Default = 1] = "Default", gt))(), Nt = (() => { return (e = Nt || (Nt = {}))[e.Emulated = 0] = "Emulated", e[e.None = 2] = "None", e[e.ShadowDom = 3] = "ShadowDom", Nt; var e })(); const X = (() => typeof globalThis < "u" && globalThis || typeof global < "u" && global || typeof window < "u" && window || typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self)(), Xn = {}, q = [], yi = Z({ \u0275cmp: Z }), Ma = Z({ \u0275dir: Z }), Ta = Z({ \u0275pipe: Z }), tf = Z({ \u0275mod: Z }), zt = Z({ \u0275fac: Z }), Jr = Z({ __NG_ELEMENT_ID__: Z }); let Xw = 0; function xn(e) { return ln(() => { const n = !0 === e.standalone, r = {}, o = { type: e.type, providersResolver: null, decls: e.decls, vars: e.vars, factory: null, template: e.template || null, consts: e.consts || null, ngContentSelectors: e.ngContentSelectors, hostBindings: e.hostBindings || null, hostVars: e.hostVars || 0, hostAttrs: e.hostAttrs || null, contentQueries: e.contentQueries || null, declaredInputs: r, inputs: null, outputs: null, exportAs: e.exportAs || null, onPush: e.changeDetection === gt.OnPush, directiveDefs: null, pipeDefs: null, standalone: n, dependencies: n && e.dependencies || null, getStandaloneInjector: null, selectors: e.selectors || q, viewQuery: e.viewQuery || null, features: e.features || null, data: e.data || {}, encapsulation: e.encapsulation || Nt.Emulated, id: "c" + Xw++, styles: e.styles || q, _: null, setInput: null, schemas: e.schemas || null, tView: null }, i = e.dependencies, s = e.features; return o.inputs = sf(e.inputs, r), o.outputs = sf(e.outputs), s && s.forEach(a => a(o)), o.directiveDefs = i ? () => ("function" == typeof i ? i() : i).map(nf).filter(rf) : null, o.pipeDefs = i ? () => ("function" == typeof i ? i() : i).map(je).filter(rf) : null, o }) } function nf(e) { return Q(e) || Le(e) } function rf(e) { return null !== e } function Gt(e) { return ln(() => ({ type: e.type, bootstrap: e.bootstrap || q, declarations: e.declarations || q, imports: e.imports || q, exports: e.exports || q, transitiveCompileScopes: null, schemas: e.schemas || null, id: e.id || null })) } function sf(e, t) { if (null == e) return Xn; const n = {}; for (const r in e) if (e.hasOwnProperty(r)) { let o = e[r], i = o; Array.isArray(o) && (i = o[1], o = o[0]), n[o] = r, t && (t[o] = i) } return n } const xe = xn; function Q(e) { return e[yi] || null } function Le(e) { return e[Ma] || null } function je(e) { return e[Ta] || null } function Ye(e, t) { const n = e[tf] || null; if (!n && !0 === t) throw new Error(`Type ${J(e)} does not have '\u0275mod' property.`); return n } const V = 11; function qe(e) { return Array.isArray(e) && "object" == typeof e[1] } function yt(e) { return Array.isArray(e) && !0 === e[1] } function Ra(e) { return 0 != (8 & e.flags) } function Ci(e) { return 2 == (2 & e.flags) } function _i(e) { return 1 == (1 & e.flags) } function vt(e) { return null !== e.template } function iC(e) { return 0 != (256 & e[2]) } function Fn(e, t) { return e.hasOwnProperty(zt) ? e[zt] : null } class uC { constructor(t, n, r) { this.previousValue = t, this.currentValue = n, this.firstChange = r } isFirstChange() { return this.firstChange } } function lf(e) { return e.type.prototype.ngOnChanges && (e.setInput = cC), lC } function lC() { const e = df(this), t = e?.current; if (t) { const n = e.previous; if (n === Xn) e.previous = t; else for (let r in t) n[r] = t[r]; e.current = null, this.ngOnChanges(t) } } function cC(e, t, n, r) { const o = df(e) || function dC(e, t) { return e[cf] = t }(e, { previous: Xn, current: null }), i = o.current || (o.current = {}), s = o.previous, a = this.declaredInputs[n], u = s[a]; i[a] = new uC(u && u.currentValue, t, s === Xn), e[r] = t } const cf = "__ngSimpleChanges__"; function df(e) { return e[cf] || null } function fe(e) { for (; Array.isArray(e);)e = e[0]; return e } function ut(e, t) { return fe(t[e.index]) } function ka(e, t) { return e.data[t] } function et(e, t) { const n = t[e]; return qe(n) ? n : n[0] } function bi(e) { return 64 == (64 & e[2]) } function cn(e, t) { return null == t ? null : e[t] } function ff(e) { e[18] = 0 } function La(e, t) { e[5] += t; let n = e, r = e[3]; for (; null !== r && (1 === t && 1 === n[5] || -1 === t && 0 === n[5]);)r[5] += t, n = r, r = r[3] } const O = { lFrame: _f(null), bindingsEnabled: !0 }; function pf() { return O.bindingsEnabled } function v() { return O.lFrame.lView } function z() { return O.lFrame.tView } function De() { let e = gf(); for (; null !== e && 64 === e.type;)e = e.parent; return e } function gf() { return O.lFrame.currentTNode } function Pt(e, t) { const n = O.lFrame; n.currentTNode = e, n.isParent = t } function ja() { return O.lFrame.isParent } function ir() { return O.lFrame.bindingIndex++ } function TC(e, t) { const n = O.lFrame; n.bindingIndex = n.bindingRootIndex = e, $a(t) } function $a(e) { O.lFrame.currentDirectiveIndex = e } function Ba(e) { O.lFrame.currentQueryIndex = e } function xC(e) { const t = e[1]; return 2 === t.type ? t.declTNode : 1 === t.type ? e[6] : null } function wf(e, t, n) { if (n & A.SkipSelf) { let o = t, i = e; for (; !(o = o.parent, null !== o || n & A.Host || (o = xC(i), null === o || (i = i[15], 10 & o.type)));); if (null === o) return !1; t = o, e = i } const r = O.lFrame = Cf(); return r.currentTNode = t, r.lView = e, !0 } function Ua(e) { const t = Cf(), n = e[1]; O.lFrame = t, t.currentTNode = n.firstChild, t.lView = e, t.tView = n, t.contextLView = e, t.bindingIndex = n.bindingStartIndex, t.inI18n = !1 } function Cf() { const e = O.lFrame, t = null === e ? null : e.child; return null === t ? _f(e) : t } function _f(e) { const t = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: e, child: null, inI18n: !1 }; return null !== e && (e.child = t), t } function Ef() { const e = O.lFrame; return O.lFrame = e.parent, e.currentTNode = null, e.lView = null, e } const bf = Ef; function za() { const e = Ef(); e.isParent = !0, e.tView = null, e.selectedIndex = -1, e.contextLView = null, e.elementDepthCount = 0, e.currentDirectiveIndex = -1, e.currentNamespace = null, e.bindingRootIndex = -1, e.bindingIndex = -1, e.currentQueryIndex = 0 } function $e() { return O.lFrame.selectedIndex } function dn(e) { O.lFrame.selectedIndex = e } function se() { const e = O.lFrame; return ka(e.tView, e.selectedIndex) } function Ii(e, t) { for (let n = t.directiveStart, r = t.directiveEnd; n < r; n++) { const i = e.data[n].type.prototype, { ngAfterContentInit: s, ngAfterContentChecked: a, ngAfterViewInit: u, ngAfterViewChecked: l, ngOnDestroy: c } = i; s && (e.contentHooks || (e.contentHooks = [])).push(-n, s), a && ((e.contentHooks || (e.contentHooks = [])).push(n, a), (e.contentCheckHooks || (e.contentCheckHooks = [])).push(n, a)), u && (e.viewHooks || (e.viewHooks = [])).push(-n, u), l && ((e.viewHooks || (e.viewHooks = [])).push(n, l), (e.viewCheckHooks || (e.viewCheckHooks = [])).push(n, l)), null != c && (e.destroyHooks || (e.destroyHooks = [])).push(n, c) } } function Si(e, t, n) { If(e, t, 3, n) } function Mi(e, t, n, r) { (3 & e[2]) === n && If(e, t, n, r) } function Ga(e, t) { let n = e[2]; (3 & n) === t && (n &= 2047, n += 1, e[2] = n) } function If(e, t, n, r) { const i = r ?? -1, s = t.length - 1; let a = 0; for (let u = void 0 !== r ? 65535 & e[18] : 0; u < s; u++)if ("number" == typeof t[u + 1]) { if (a = t[u], null != r && a >= r) break } else t[u] < 0 && (e[18] += 65536), (a < i || -1 == i) && (VC(e, n, t, u), e[18] = (4294901760 & e[18]) + u + 2), u++ } function VC(e, t, n, r) { const o = n[r] < 0, i = n[r + 1], a = e[o ? -n[r] : n[r]]; if (o) { if (e[2] >> 11 < e[18] >> 16 && (3 & e[2]) === t) { e[2] += 2048; try { i.call(a) } finally { } } } else try { i.call(a) } finally { } } class ro { constructor(t, n, r) { this.factory = t, this.resolving = !1, this.canSeeViewProviders = n, this.injectImpl = r } } function Ti(e, t, n) { let r = 0; for (; r < n.length;) { const o = n[r]; if ("number" == typeof o) { if (0 !== o) break; r++; const i = n[r++], s = n[r++], a = n[r++]; e.setAttribute(t, s, a, i) } else { const i = o, s = n[++r]; Mf(i) ? e.setProperty(t, i, s) : e.setAttribute(t, i, s), r++ } } return r } function Sf(e) { return 3 === e || 4 === e || 6 === e } function Mf(e) { return 64 === e.charCodeAt(0) } function Ai(e, t) { if (null !== t && 0 !== t.length) if (null === e || 0 === e.length) e = t.slice(); else { let n = -1; for (let r = 0; r < t.length; r++) { const o = t[r]; "number" == typeof o ? n = o : 0 === n || Tf(e, n, o, null, -1 === n || 2 === n ? t[++r] : null) } } return e } function Tf(e, t, n, r, o) { let i = 0, s = e.length; if (-1 === t) s = -1; else for (; i < e.length;) { const a = e[i++]; if ("number" == typeof a) { if (a === t) { s = -1; break } if (a > t) { s = i - 1; break } } } for (; i < e.length;) { const a = e[i]; if ("number" == typeof a) break; if (a === n) { if (null === r) return void (null !== o && (e[i + 1] = o)); if (r === e[i + 1]) return void (e[i + 2] = o) } i++, null !== r && i++, null !== o && i++ } -1 !== s && (e.splice(s, 0, t), i = s + 1), e.splice(i++, 0, n), null !== r && e.splice(i++, 0, r), null !== o && e.splice(i++, 0, o) } function Af(e) { return -1 !== e } function sr(e) { return 32767 & e } function ar(e, t) { let n = function zC(e) { return e >> 16 }(e), r = t; for (; n > 0;)r = r[15], n--; return r } let qa = !0; function xi(e) { const t = qa; return qa = e, t } let GC = 0; const Ot = {}; function io(e, t) { const n = Qa(e, t); if (-1 !== n) return n; const r = t[1]; r.firstCreatePass && (e.injectorIndex = t.length, Ka(r.data, e), Ka(t, null), Ka(r.blueprint, null)); const o = Ri(e, t), i = e.injectorIndex; if (Af(o)) { const s = sr(o), a = ar(o, t), u = a[1].data; for (let l = 0; l < 8; l++)t[i + l] = a[s + l] | u[s + l] } return t[i + 8] = o, i } function Ka(e, t) { e.push(0, 0, 0, 0, 0, 0, 0, 0, t) } function Qa(e, t) { return -1 === e.injectorIndex || e.parent && e.parent.injectorIndex === e.injectorIndex || null === t[e.injectorIndex + 8] ? -1 : e.injectorIndex } function Ri(e, t) { if (e.parent && -1 !== e.parent.injectorIndex) return e.parent.injectorIndex; let n = 0, r = null, o = t; for (; null !== o;) { if (r = jf(o), null === r) return -1; if (n++, o = o[15], -1 !== r.injectorIndex) return r.injectorIndex | n << 16 } return -1 } function Ni(e, t, n) { !function WC(e, t, n) { let r; "string" == typeof n ? r = n.charCodeAt(0) || 0 : n.hasOwnProperty(Jr) && (r = n[Jr]), null == r && (r = n[Jr] = GC++); const o = 255 & r; t.data[e + (o >> 5)] |= 1 << o }(e, t, n) } function Nf(e, t, n) { if (n & A.Optional || void 0 !== e) return e; pi() } function Pf(e, t, n, r) { if (n & A.Optional && void 0 === r && (r = null), 0 == (n & (A.Self | A.Host))) { const o = e[9], i = it(void 0); try { return o ? o.get(t, r, n & A.Optional) : ef(t, r, n & A.Optional) } finally { it(i) } } return Nf(r, 0, n) } function Of(e, t, n, r = A.Default, o) { if (null !== e) { if (1024 & t[2]) { const s = function YC(e, t, n, r, o) { let i = e, s = t; for (; null !== i && null !== s && 1024 & s[2] && !(256 & s[2]);) { const a = Ff(i, s, n, r | A.Self, Ot); if (a !== Ot) return a; let u = i.parent; if (!u) { const l = s[21]; if (l) { const c = l.get(n, Ot, r); if (c !== Ot) return c } u = jf(s), s = s[15] } i = u } return o }(e, t, n, r, Ot); if (s !== Ot) return s } const i = Ff(e, t, n, r, Ot); if (i !== Ot) return i } return Pf(t, n, r, o) } function Ff(e, t, n, r, o) { const i = function QC(e) { if ("string" == typeof e) return e.charCodeAt(0) || 0; const t = e.hasOwnProperty(Jr) ? e[Jr] : void 0; return "number" == typeof t ? t >= 0 ? 255 & t : ZC : t }(n); if ("function" == typeof i) { if (!wf(t, e, r)) return r & A.Host ? Nf(o, 0, r) : Pf(t, n, r, o); try { const s = i(r); if (null != s || r & A.Optional) return s; pi() } finally { bf() } } else if ("number" == typeof i) { let s = null, a = Qa(e, t), u = -1, l = r & A.Host ? t[16][6] : null; for ((-1 === a || r & A.SkipSelf) && (u = -1 === a ? Ri(e, t) : t[a + 8], -1 !== u && Lf(r, !1) ? (s = t[1], a = sr(u), t = ar(u, t)) : a = -1); -1 !== a;) { const c = t[1]; if (kf(i, a, c.data)) { const d = KC(a, t, n, s, r, l); if (d !== Ot) return d } u = t[a + 8], -1 !== u && Lf(r, t[1].data[a + 8] === l) && kf(i, a, t) ? (s = c, a = sr(u), t = ar(u, t)) : a = -1 } } return o } function KC(e, t, n, r, o, i) { const s = t[1], a = s.data[e + 8], c = function Pi(e, t, n, r, o) { const i = e.providerIndexes, s = t.data, a = 1048575 & i, u = e.directiveStart, c = i >> 20, f = o ? a + c : e.directiveEnd; for (let h = r ? a : a + c; h < f; h++) { const p = s[h]; if (h < u && n === p || h >= u && p.type === n) return h } if (o) { const h = s[u]; if (h && vt(h) && h.type === n) return u } return null }(a, s, n, null == r ? Ci(a) && qa : r != s && 0 != (3 & a.type), o & A.Host && i === a); return null !== c ? so(t, s, c, a) : Ot } function so(e, t, n, r) { let o = e[n]; const i = t.data; if (function $C(e) { return e instanceof ro }(o)) { const s = o; s.resolving && function Uw(e, t) { const n = t ? `. Dependency path: ${t.join(" > ")} > ${e}` : ""; throw new E(-200, `Circular dependency in DI detected for ${e}${n}`) }(function W(e) { return "function" == typeof e ? e.name || e.toString() : "object" == typeof e && null != e && "function" == typeof e.type ? e.type.name || e.type.toString() : F(e) }(i[n])); const a = xi(s.canSeeViewProviders); s.resolving = !0; const u = s.injectImpl ? it(s.injectImpl) : null; wf(e, r, A.Default); try { o = e[n] = s.factory(void 0, i, e, r), t.firstCreatePass && n >= r.directiveStart && function jC(e, t, n) { const { ngOnChanges: r, ngOnInit: o, ngDoCheck: i } = t.type.prototype; if (r) { const s = lf(t); (n.preOrderHooks || (n.preOrderHooks = [])).push(e, s), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(e, s) } o && (n.preOrderHooks || (n.preOrderHooks = [])).push(0 - e, o), i && ((n.preOrderHooks || (n.preOrderHooks = [])).push(e, i), (n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(e, i)) }(n, i[n], t) } finally { null !== u && it(u), xi(a), s.resolving = !1, bf() } } return o } function kf(e, t, n) { return !!(n[t + (e >> 5)] & 1 << e) } function Lf(e, t) { return !(e & A.Self || e & A.Host && t) } class ur { constructor(t, n) { this._tNode = t, this._lView = n } get(t, n, r) { return Of(this._tNode, this._lView, t, r, n) } } function ZC() { return new ur(De(), v()) } function jf(e) { const t = e[1], n = t.type; return 2 === n ? t.declTNode : 1 === n ? e[6] : null } const cr = "__parameters__"; function fr(e, t, n) { return ln(() => { const r = function Ja(e) { return function (...n) { if (e) { const r = e(...n); for (const o in r) this[o] = r[o] } } }(t); function o(...i) { if (this instanceof o) return r.apply(this, i), this; const s = new o(...i); return a.annotation = s, a; function a(u, l, c) { const d = u.hasOwnProperty(cr) ? u[cr] : Object.defineProperty(u, cr, { value: [] })[cr]; for (; d.length <= c;)d.push(null); return (d[c] = d[c] || []).push(s), u } } return n && (o.prototype = Object.create(n.prototype)), o.prototype.ngMetadataName = e, o.annotationCls = o, o }) } class P { constructor(t, n) { this._desc = t, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof n ? this.__NG_ELEMENT_ID__ = n : void 0 !== n && (this.\u0275prov = N({ token: this, providedIn: n.providedIn || "root", factory: n.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } } function Kt(e, t) { e.forEach(n => Array.isArray(n) ? Kt(n, t) : t(n)) } function $f(e, t, n) { t >= e.length ? e.push(n) : e.splice(t, 0, n) } function Oi(e, t) { return t >= e.length - 1 ? e.pop() : e.splice(t, 1)[0] } const fo = {}, tu = "__NG_DI_FLAG__", ki = "ngTempTokenPath", c_ = /\n/gm, zf = "__source"; let ho; function pr(e) { const t = ho; return ho = e, t } function f_(e, t = A.Default) { if (void 0 === ho) throw new E(-203, !1); return null === ho ? ef(e, void 0, t) : ho.get(e, t & A.Optional ? null : void 0, t) } function b(e, t = A.Default) { return (function Yw() { return Sa }() || f_)(R(e), t) } function ue(e, t = A.Default) { return "number" != typeof t && (t = 0 | (t.optional && 8) | (t.host && 1) | (t.self && 2) | (t.skipSelf && 4)), b(e, t) } function nu(e) { const t = []; for (let n = 0; n < e.length; n++) { const r = R(e[n]); if (Array.isArray(r)) { if (0 === r.length) throw new E(900, !1); let o, i = A.Default; for (let s = 0; s < r.length; s++) { const a = r[s], u = h_(a); "number" == typeof u ? -1 === u ? o = a.token : i |= u : o = a } t.push(b(o, i)) } else t.push(b(r)) } return t } function po(e, t) { return e[tu] = t, e.prototype[tu] = t, e } function h_(e) { return e[tu] } const go = po(fr("Optional"), 8), mo = po(fr("SkipSelf"), 4); let ou; class rh { constructor(t) { this.changingThisBreaksApplicationSecurity = t } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)` } } const L_ = /^(?:(?:https?|mailto|data|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi; var he = (() => ((he = he || {})[he.NONE = 0] = "NONE", he[he.HTML = 1] = "HTML", he[he.STYLE = 2] = "STYLE", he[he.SCRIPT = 3] = "SCRIPT", he[he.URL = 4] = "URL", he[he.RESOURCE_URL = 5] = "RESOURCE_URL", he))(); function Bi(e) { const t = function Co() { const e = v(); return e && e[12] }(); return t ? t.sanitize(he.URL, e) || "" : function Do(e, t) { const n = function P_(e) { return e instanceof rh && e.getTypeName() || null }(e); if (null != n && n !== t) { if ("ResourceURL" === n && "URL" === t) return !0; throw new Error(`Required a safe ${t}, got a ${n} (see https://g.co/ng/security#xss)`) } return n === t }(e, "URL") ? function hn(e) { return e instanceof rh ? e.changingThisBreaksApplicationSecurity : e }(e) : function au(e) { return (e = String(e)).match(L_) ? e : "unsafe:" + e }(F(e)) } const du = new P("ENVIRONMENT_INITIALIZER"), dh = new P("INJECTOR", -1), fh = new P("INJECTOR_DEF_TYPES"); class hh { get(t, n = fo) { if (n === fo) { const r = new Error(`NullInjectorError: No provider for ${J(t)}!`); throw r.name = "NullInjectorError", r } return n } } function J_(...e) { return { \u0275providers: ph(0, e) } } function ph(e, ...t) { const n = [], r = new Set; let o; return Kt(t, i => { const s = i; fu(s, n, [], r) && (o || (o = []), o.push(s)) }), void 0 !== o && gh(o, n), n } function gh(e, t) { for (let n = 0; n < e.length; n++) { const { providers: o } = e[n]; Kt(o, i => { t.push(i) }) } } function fu(e, t, n, r) { if (!(e = R(e))) return !1; let o = null, i = Yd(e); const s = !i && Q(e); if (i || s) { if (s && !s.standalone) return !1; o = e } else { const u = e.ngModule; if (i = Yd(u), !i) return !1; o = u } const a = r.has(o); if (s) { if (a) return !1; if (r.add(o), s.dependencies) { const u = "function" == typeof s.dependencies ? s.dependencies() : s.dependencies; for (const l of u) fu(l, t, n, r) } } else { if (!i) return !1; { if (null != i.imports && !a) { let l; r.add(o); try { Kt(i.imports, c => { fu(c, t, n, r) && (l || (l = []), l.push(c)) }) } finally { } void 0 !== l && gh(l, t) } if (!a) { const l = Fn(o) || (() => new o); t.push({ provide: o, useFactory: l, deps: q }, { provide: fh, useValue: o, multi: !0 }, { provide: du, useValue: () => b(o), multi: !0 }) } const u = i.providers; null == u || a || Kt(u, c => { t.push(c) }) } } return o !== e && void 0 !== e.providers } const Y_ = Z({ provide: String, useValue: Z }); function hu(e) { return null !== e && "object" == typeof e && Y_ in e } function Ln(e) { return "function" == typeof e } const pu = new P("Set Injector scope."), Ui = {}, eE = {}; let gu; function zi() { return void 0 === gu && (gu = new hh), gu } class pn { } class vh extends pn { constructor(t, n, r, o) { super(), this.parent = n, this.source = r, this.scopes = o, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, yu(t, s => this.processProvider(s)), this.records.set(dh, yr(void 0, this)), o.has("environment") && this.records.set(pn, yr(void 0, this)); const i = this.records.get(pu); null != i && "string" == typeof i.value && this.scopes.add(i.value), this.injectorDefTypes = new Set(this.get(fh.multi, q, A.Self)) } get destroyed() { return this._destroyed } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { for (const t of this._ngOnDestroyHooks) t.ngOnDestroy(); for (const t of this._onDestroyHooks) t() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear(), this._onDestroyHooks.length = 0 } } onDestroy(t) { this._onDestroyHooks.push(t) } runInContext(t) { this.assertNotDestroyed(); const n = pr(this), r = it(void 0); try { return t() } finally { pr(n), it(r) } } get(t, n = fo, r = A.Default) { this.assertNotDestroyed(); const o = pr(this), i = it(void 0); try { if (!(r & A.SkipSelf)) { let a = this.records.get(t); if (void 0 === a) { const u = function iE(e) { return "function" == typeof e || "object" == typeof e && e instanceof P }(t) && gi(t); a = u && this.injectableDefInScope(u) ? yr(mu(t), Ui) : null, this.records.set(t, a) } if (null != a) return this.hydrate(t, a) } return (r & A.Self ? zi() : this.parent).get(t, n = r & A.Optional && n === fo ? null : n) } catch (s) { if ("NullInjectorError" === s.name) { if ((s[ki] = s[ki] || []).unshift(J(t)), o) throw s; return function p_(e, t, n, r) { const o = e[ki]; throw t[zf] && o.unshift(t[zf]), e.message = function g_(e, t, n, r = null) { e = e && "\n" === e.charAt(0) && "\u0275" == e.charAt(1) ? e.slice(2) : e; let o = J(t); if (Array.isArray(t)) o = t.map(J).join(" -> "); else if ("object" == typeof t) { let i = []; for (let s in t) if (t.hasOwnProperty(s)) { let a = t[s]; i.push(s + ":" + ("string" == typeof a ? JSON.stringify(a) : J(a))) } o = `{${i.join(", ")}}` } return `${n}${r ? "(" + r + ")" : ""}[${o}]: ${e.replace(c_, "\n  ")}` }("\n" + e.message, o, n, r), e.ngTokenPath = o, e[ki] = null, e }(s, t, "R3InjectorError", this.source) } throw s } finally { it(i), pr(o) } } resolveInjectorInitializers() { const t = pr(this), n = it(void 0); try { const r = this.get(du.multi, q, A.Self); for (const o of r) o() } finally { pr(t), it(n) } } toString() { const t = [], n = this.records; for (const r of n.keys()) t.push(J(r)); return `R3Injector[${t.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new E(205, !1) } processProvider(t) { let n = Ln(t = R(t)) ? t : R(t && t.provide); const r = function nE(e) { return hu(e) ? yr(void 0, e.useValue) : yr(function Dh(e, t, n) { let r; if (Ln(e)) { const o = R(e); return Fn(o) || mu(o) } if (hu(e)) r = () => R(e.useValue); else if (function yh(e) { return !(!e || !e.useFactory) }(e)) r = () => e.useFactory(...nu(e.deps || [])); else if (function mh(e) { return !(!e || !e.useExisting) }(e)) r = () => b(R(e.useExisting)); else { const o = R(e && (e.useClass || e.provide)); if (!function rE(e) { return !!e.deps }(e)) return Fn(o) || mu(o); r = () => new o(...nu(e.deps)) } return r }(e), Ui) }(t); if (Ln(t) || !0 !== t.multi) this.records.get(n); else { let o = this.records.get(n); o || (o = yr(void 0, Ui, !0), o.factory = () => nu(o.multi), this.records.set(n, o)), n = t, o.multi.push(t) } this.records.set(n, r) } hydrate(t, n) { return n.value === Ui && (n.value = eE, n.value = n.factory()), "object" == typeof n.value && n.value && function oE(e) { return null !== e && "object" == typeof e && "function" == typeof e.ngOnDestroy }(n.value) && this._ngOnDestroyHooks.add(n.value), n.value } injectableDefInScope(t) { if (!t.providedIn) return !1; const n = R(t.providedIn); return "string" == typeof n ? "any" === n || this.scopes.has(n) : this.injectorDefTypes.has(n) } } function mu(e) { const t = gi(e), n = null !== t ? t.factory : Fn(e); if (null !== n) return n; if (e instanceof P) throw new E(204, !1); if (e instanceof Function) return function tE(e) { const t = e.length; if (t > 0) throw function co(e, t) { const n = []; for (let r = 0; r < e; r++)n.push(t); return n }(t, "?"), new E(204, !1); const n = function Qw(e) { const t = e && (e[mi] || e[Xd]); if (t) { const n = function Zw(e) { if (e.hasOwnProperty("name")) return e.name; const t = ("" + e).match(/^function\s*([^\s(]+)/); return null === t ? "" : t[1] }(e); return console.warn(`DEPRECATED: DI is instantiating a token "${n}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${n}" class.`), t } return null }(e); return null !== n ? () => n.factory(e) : () => new e }(e); throw new E(204, !1) } function yr(e, t, n = !1) { return { factory: e, value: t, multi: n ? [] : void 0 } } function sE(e) { return !!e.\u0275providers } function yu(e, t) { for (const n of e) Array.isArray(n) ? yu(n, t) : sE(n) ? yu(n.\u0275providers, t) : t(n) } class wh { } class lE { resolveComponentFactory(t) { throw function uE(e) { const t = Error(`No component factory found for ${J(e)}. Did you add it to @NgModule.entryComponents?`); return t.ngComponent = e, t }(t) } } let _o = (() => { class e { } return e.NULL = new lE, e })(); function cE() { return vr(De(), v()) } function vr(e, t) { return new gn(ut(e, t)) } let gn = (() => { class e { constructor(n) { this.nativeElement = n } } return e.__NG_ELEMENT_ID__ = cE, e })(); class _h { } let hE = (() => { class e { } return e.\u0275prov = N({ token: e, providedIn: "root", factory: () => null }), e })(); class Wi { constructor(t) { this.full = t, this.major = t.split(".")[0], this.minor = t.split(".")[1], this.patch = t.split(".").slice(2).join(".") } } const pE = new Wi("14.2.10"), vu = {}; function Eu(e) { return e.ngOriginalError } class Dr { constructor() { this._console = console } handleError(t) { const n = this._findOriginalError(t); this._console.error("ERROR", t), n && this._console.error("ORIGINAL ERROR", n) } _findOriginalError(t) { let n = t && Eu(t); for (; n && Eu(n);)n = Eu(n); return n || null } } const bu = new Map; let SE = 0; const Su = "__ngContext__"; function Pe(e, t) { qe(t) ? (e[Su] = t[20], function TE(e) { bu.set(e[20], e) }(t)) : e[Su] = t } function Zt(e) { return e instanceof Function ? e() : e } var Ke = (() => ((Ke = Ke || {})[Ke.Important = 1] = "Important", Ke[Ke.DashCase = 2] = "DashCase", Ke))(); function Tu(e, t) { return undefined(e, t) } function bo(e) { const t = e[3]; return yt(t) ? t[3] : t } function Au(e) { return kh(e[13]) } function xu(e) { return kh(e[4]) } function kh(e) { for (; null !== e && !yt(e);)e = e[4]; return e } function Cr(e, t, n, r, o) { if (null != r) { let i, s = !1; yt(r) ? i = r : qe(r) && (s = !0, r = r[0]); const a = fe(r); 0 === e && null !== n ? null == o ? Bh(t, n, a) : jn(t, n, a, o || null, !0) : 1 === e && null !== n ? jn(t, n, a, o || null, !0) : 2 === e ? function Qh(e, t, n) { const r = qi(e, t); r && function tb(e, t, n, r) { e.removeChild(t, n, r) }(e, r, t, n) }(t, a, s) : 3 === e && t.destroyNode(a), null != i && function ob(e, t, n, r, o) { const i = n[7]; i !== fe(n) && Cr(t, e, r, i, o); for (let a = 10; a < n.length; a++) { const u = n[a]; Io(u[1], u, e, t, r, i) } }(t, e, i, n, o) } } function Nu(e, t, n) { return e.createElement(t, n) } function jh(e, t) { const n = e[9], r = n.indexOf(t), o = t[3]; 512 & t[2] && (t[2] &= -513, La(o, -1)), n.splice(r, 1) } function Pu(e, t) { if (e.length <= 10) return; const n = 10 + t, r = e[n]; if (r) { const o = r[17]; null !== o && o !== e && jh(o, r), t > 0 && (e[n - 1][4] = r[4]); const i = Oi(e, 10 + t); !function qE(e, t) { Io(e, t, t[V], 2, null, null), t[0] = null, t[6] = null }(r[1], r); const s = i[19]; null !== s && s.detachView(i[1]), r[3] = null, r[4] = null, r[2] &= -65 } return r } function Vh(e, t) { if (!(128 & t[2])) { const n = t[V]; n.destroyNode && Io(e, t, n, 3, null, null), function ZE(e) { let t = e[13]; if (!t) return Ou(e[1], e); for (; t;) { let n = null; if (qe(t)) n = t[13]; else { const r = t[10]; r && (n = r) } if (!n) { for (; t && !t[4] && t !== e;)qe(t) && Ou(t[1], t), t = t[3]; null === t && (t = e), qe(t) && Ou(t[1], t), n = t && t[4] } t = n } }(t) } } function Ou(e, t) { if (!(128 & t[2])) { t[2] &= -65, t[2] |= 128, function eb(e, t) { let n; if (null != e && null != (n = e.destroyHooks)) for (let r = 0; r < n.length; r += 2) { const o = t[n[r]]; if (!(o instanceof ro)) { const i = n[r + 1]; if (Array.isArray(i)) for (let s = 0; s < i.length; s += 2) { const a = o[i[s]], u = i[s + 1]; try { u.call(a) } finally { } } else try { i.call(o) } finally { } } } }(e, t), function XE(e, t) { const n = e.cleanup, r = t[7]; let o = -1; if (null !== n) for (let i = 0; i < n.length - 1; i += 2)if ("string" == typeof n[i]) { const s = n[i + 1], a = "function" == typeof s ? s(t) : fe(t[s]), u = r[o = n[i + 2]], l = n[i + 3]; "boolean" == typeof l ? a.removeEventListener(n[i], u, l) : l >= 0 ? r[o = l]() : r[o = -l].unsubscribe(), i += 2 } else { const s = r[o = n[i + 1]]; n[i].call(s) } if (null !== r) { for (let i = o + 1; i < r.length; i++)(0, r[i])(); t[7] = null } }(e, t), 1 === t[1].type && t[V].destroy(); const n = t[17]; if (null !== n && yt(t[3])) { n !== t[3] && jh(n, t); const r = t[19]; null !== r && r.detachView(e) } !function AE(e) { bu.delete(e[20]) }(t) } } function $h(e, t, n) { return function Hh(e, t, n) { let r = t; for (; null !== r && 40 & r.type;)r = (t = r).parent; if (null === r) return n[0]; if (2 & r.flags) { const o = e.data[r.directiveStart].encapsulation; if (o === Nt.None || o === Nt.Emulated) return null } return ut(r, n) }(e, t.parent, n) } function jn(e, t, n, r, o) { e.insertBefore(t, n, r, o) } function Bh(e, t, n) { e.appendChild(t, n) } function Uh(e, t, n, r, o) { null !== r ? jn(e, t, n, r, o) : Bh(e, t, n) } function qi(e, t) { return e.parentNode(t) } let Wh = function Gh(e, t, n) { return 40 & e.type ? ut(e, n) : null }; function Ki(e, t, n, r) { const o = $h(e, r, t), i = t[V], a = function zh(e, t, n) { return Wh(e, t, n) }(r.parent || t[6], r, t); if (null != o) if (Array.isArray(n)) for (let u = 0; u < n.length; u++)Uh(i, o, n[u], a, !1); else Uh(i, o, n, a, !1) } function Qi(e, t) { if (null !== t) { const n = t.type; if (3 & n) return ut(t, e); if (4 & n) return ku(-1, e[t.index]); if (8 & n) { const r = t.child; if (null !== r) return Qi(e, r); { const o = e[t.index]; return yt(o) ? ku(-1, o) : fe(o) } } if (32 & n) return Tu(t, e)() || fe(e[t.index]); { const r = Kh(e, t); return null !== r ? Array.isArray(r) ? r[0] : Qi(bo(e[16]), r) : Qi(e, t.next) } } return null } function Kh(e, t) { return null !== t ? e[16][6].projection[t.projection] : null } function ku(e, t) { const n = 10 + e + 1; if (n < t.length) { const r = t[n], o = r[1].firstChild; if (null !== o) return Qi(r, o) } return t[7] } function Lu(e, t, n, r, o, i, s) { for (; null != n;) { const a = r[n.index], u = n.type; if (s && 0 === t && (a && Pe(fe(a), r), n.flags |= 4), 64 != (64 & n.flags)) if (8 & u) Lu(e, t, n.child, r, o, i, !1), Cr(t, e, o, a, i); else if (32 & u) { const l = Tu(n, r); let c; for (; c = l();)Cr(t, e, o, c, i); Cr(t, e, o, a, i) } else 16 & u ? Zh(e, t, r, n, o, i) : Cr(t, e, o, a, i); n = s ? n.projectionNext : n.next } } function Io(e, t, n, r, o, i) { Lu(n, r, e.firstChild, t, o, i, !1) } function Zh(e, t, n, r, o, i) { const s = n[16], u = s[6].projection[r.projection]; if (Array.isArray(u)) for (let l = 0; l < u.length; l++)Cr(t, e, o, u[l], i); else Lu(e, t, u, s[3], o, i, !0) } function Jh(e, t, n) { e.setAttribute(t, "style", n) } function ju(e, t, n) { "" === n ? e.removeAttribute(t, "class") : e.setAttribute(t, "class", n) } function Yh(e, t, n) { let r = e.length; for (; ;) { const o = e.indexOf(t, n); if (-1 === o) return o; if (0 === o || e.charCodeAt(o - 1) <= 32) { const i = t.length; if (o + i === r || e.charCodeAt(o + i) <= 32) return o } n = o + 1 } } const Xh = "ng-template"; function sb(e, t, n) { let r = 0; for (; r < e.length;) { let o = e[r++]; if (n && "class" === o) { if (o = e[r], -1 !== Yh(o.toLowerCase(), t, 0)) return !0 } else if (1 === o) { for (; r < e.length && "string" == typeof (o = e[r++]);)if (o.toLowerCase() === t) return !0; return !1 } } return !1 } function ep(e) { return 4 === e.type && e.value !== Xh } function ab(e, t, n) { return t === (4 !== e.type || n ? e.value : Xh) } function ub(e, t, n) { let r = 4; const o = e.attrs || [], i = function db(e) { for (let t = 0; t < e.length; t++)if (Sf(e[t])) return t; return e.length }(o); let s = !1; for (let a = 0; a < t.length; a++) { const u = t[a]; if ("number" != typeof u) { if (!s) if (4 & r) { if (r = 2 | 1 & r, "" !== u && !ab(e, u, n) || "" === u && 1 === t.length) { if (Dt(r)) return !1; s = !0 } } else { const l = 8 & r ? u : t[++a]; if (8 & r && null !== e.attrs) { if (!sb(e.attrs, l, n)) { if (Dt(r)) return !1; s = !0 } continue } const d = lb(8 & r ? "class" : u, o, ep(e), n); if (-1 === d) { if (Dt(r)) return !1; s = !0; continue } if ("" !== l) { let f; f = d > i ? "" : o[d + 1].toLowerCase(); const h = 8 & r ? f : null; if (h && -1 !== Yh(h, l, 0) || 2 & r && l !== f) { if (Dt(r)) return !1; s = !0 } } } } else { if (!s && !Dt(r) && !Dt(u)) return !1; if (s && Dt(u)) continue; s = !1, r = u | 1 & r } } return Dt(r) || s } function Dt(e) { return 0 == (1 & e) } function lb(e, t, n, r) { if (null === t) return -1; let o = 0; if (r || !n) { let i = !1; for (; o < t.length;) { const s = t[o]; if (s === e) return o; if (3 === s || 6 === s) i = !0; else { if (1 === s || 2 === s) { let a = t[++o]; for (; "string" == typeof a;)a = t[++o]; continue } if (4 === s) break; if (0 === s) { o += 4; continue } } o += i ? 1 : 2 } return -1 } return function fb(e, t) { let n = e.indexOf(4); if (n > -1) for (n++; n < e.length;) { const r = e[n]; if ("number" == typeof r) return -1; if (r === t) return n; n++ } return -1 }(t, e) } function tp(e, t, n = !1) { for (let r = 0; r < t.length; r++)if (ub(e, t[r], n)) return !0; return !1 } function np(e, t) { return e ? ":not(" + t.trim() + ")" : t } function pb(e) { let t = e[0], n = 1, r = 2, o = "", i = !1; for (; n < e.length;) { let s = e[n]; if ("string" == typeof s) if (2 & r) { const a = e[++n]; o += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]" } else 8 & r ? o += "." + s : 4 & r && (o += " " + s); else "" !== o && !Dt(s) && (t += np(i, o), o = ""), r = s, i = i || !Dt(r); n++ } return "" !== o && (t += np(i, o)), t } const k = {}; function Vn(e) { rp(z(), v(), $e() + e, !1) } function rp(e, t, n, r) { if (!r) if (3 == (3 & t[2])) { const i = e.preOrderCheckHooks; null !== i && Si(t, i, n) } else { const i = e.preOrderHooks; null !== i && Mi(t, i, 0, n) } dn(n) } function ap(e, t = null, n = null, r) { const o = up(e, t, n, r); return o.resolveInjectorInitializers(), o } function up(e, t = null, n = null, r, o = new Set) { const i = [n || q, J_(e)]; return r = r || ("object" == typeof e ? void 0 : J(e)), new vh(i, t || zi(), r || null, o) } let lt = (() => { class e { static create(n, r) { if (Array.isArray(n)) return ap({ name: "" }, r, n, ""); { const o = n.name ?? ""; return ap({ name: o }, n.parent, n.providers, o) } } } return e.THROW_IF_NOT_FOUND = fo, e.NULL = new hh, e.\u0275prov = N({ token: e, providedIn: "any", factory: () => b(dh) }), e.__NG_ELEMENT_ID__ = -1, e })(); function I(e, t = A.Default) { const n = v(); return null === n ? b(e, t) : Of(De(), n, R(e), t) } function Uu() { throw new Error("invalid") } function Ip(e, t) { const n = e.contentQueries; if (null !== n) for (let r = 0; r < n.length; r += 2) { const o = n[r], i = n[r + 1]; if (-1 !== i) { const s = e.data[i]; Ba(o), s.contentQueries(2, t[i], i) } } } function es(e, t, n, r, o, i, s, a, u, l, c) { const d = t.blueprint.slice(); return d[0] = o, d[2] = 76 | r, (null !== c || e && 1024 & e[2]) && (d[2] |= 1024), ff(d), d[3] = d[15] = e, d[8] = n, d[10] = s || e && e[10], d[V] = a || e && e[V], d[12] = u || e && e[12] || null, d[9] = l || e && e[9] || null, d[6] = i, d[20] = function ME() { return SE++ }(), d[21] = c, d[16] = 2 == t.type ? e[16] : d, d } function Er(e, t, n, r, o) { let i = e.data[t]; if (null === i) i = function el(e, t, n, r, o) { const i = gf(), s = ja(), u = e.data[t] = function Zb(e, t, n, r, o, i) { return { type: n, index: r, insertBeforeIndex: null, injectorIndex: t ? t.injectorIndex : -1, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, propertyBindings: null, flags: 0, providerIndexes: 0, value: o, attrs: i, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tViews: null, next: null, projectionNext: null, child: null, parent: t, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, s ? i : i && i.parent, n, t, r, o); return null === e.firstChild && (e.firstChild = u), null !== i && (s ? null == i.child && null !== u.parent && (i.child = u) : null === i.next && (i.next = u)), u }(e, t, n, r, o), function MC() { return O.lFrame.inI18n }() && (i.flags |= 64); else if (64 & i.type) { i.type = n, i.value = r, i.attrs = o; const s = function no() { const e = O.lFrame, t = e.currentTNode; return e.isParent ? t : t.parent }(); i.injectorIndex = null === s ? -1 : s.injectorIndex } return Pt(i, !0), i } function br(e, t, n, r) { if (0 === n) return -1; const o = t.length; for (let i = 0; i < n; i++)t.push(r), e.blueprint.push(r), e.data.push(null); return o } function tl(e, t, n) { Ua(t); try { const r = e.viewQuery; null !== r && ll(1, r, n); const o = e.template; null !== o && Sp(e, t, o, 1, n), e.firstCreatePass && (e.firstCreatePass = !1), e.staticContentQueries && Ip(e, t), e.staticViewQueries && ll(2, e.viewQuery, n); const i = e.components; null !== i && function qb(e, t) { for (let n = 0; n < t.length; n++)h0(e, t[n]) }(t, i) } catch (r) { throw e.firstCreatePass && (e.incompleteFirstPass = !0, e.firstCreatePass = !1), r } finally { t[2] &= -5, za() } } function ts(e, t, n, r) { const o = t[2]; if (128 != (128 & o)) { Ua(t); try { ff(t), function yf(e) { return O.lFrame.bindingIndex = e }(e.bindingStartIndex), null !== n && Sp(e, t, n, 2, r); const s = 3 == (3 & o); if (s) { const l = e.preOrderCheckHooks; null !== l && Si(t, l, null) } else { const l = e.preOrderHooks; null !== l && Mi(t, l, 0, null), Ga(t, 0) } if (function d0(e) { for (let t = Au(e); null !== t; t = xu(t)) { if (!t[2]) continue; const n = t[9]; for (let r = 0; r < n.length; r++) { const o = n[r], i = o[3]; 0 == (512 & o[2]) && La(i, 1), o[2] |= 512 } } }(t), function c0(e) { for (let t = Au(e); null !== t; t = xu(t))for (let n = 10; n < t.length; n++) { const r = t[n], o = r[1]; bi(r) && ts(o, r, o.template, r[8]) } }(t), null !== e.contentQueries && Ip(e, t), s) { const l = e.contentCheckHooks; null !== l && Si(t, l) } else { const l = e.contentHooks; null !== l && Mi(t, l, 1), Ga(t, 1) } !function Gb(e, t) { const n = e.hostBindingOpCodes; if (null !== n) try { for (let r = 0; r < n.length; r++) { const o = n[r]; if (o < 0) dn(~o); else { const i = o, s = n[++r], a = n[++r]; TC(s, i), a(2, t[i]) } } } finally { dn(-1) } }(e, t); const a = e.components; null !== a && function Wb(e, t) { for (let n = 0; n < t.length; n++)f0(e, t[n]) }(t, a); const u = e.viewQuery; if (null !== u && ll(2, u, r), s) { const l = e.viewCheckHooks; null !== l && Si(t, l) } else { const l = e.viewHooks; null !== l && Mi(t, l, 2), Ga(t, 2) } !0 === e.firstUpdatePass && (e.firstUpdatePass = !1), t[2] &= -41, 512 & t[2] && (t[2] &= -513, La(t[3], -1)) } finally { za() } } } function Sp(e, t, n, r, o) { const i = $e(), s = 2 & r; try { dn(-1), s && t.length > 22 && rp(e, t, 22, !1), n(r, o) } finally { dn(i) } } function nl(e, t, n) { !pf() || (function t0(e, t, n, r) { const o = n.directiveStart, i = n.directiveEnd; e.firstCreatePass || io(n, t), Pe(r, t); const s = n.initialInputs; for (let a = o; a < i; a++) { const u = e.data[a], l = vt(u); l && a0(t, n, u); const c = so(t, e, a, n); Pe(c, t), null !== s && u0(0, a - o, c, u, 0, s), l && (et(n.index, t)[8] = c) } }(e, t, n, ut(n, t)), 128 == (128 & n.flags) && function n0(e, t, n) { const r = n.directiveStart, o = n.directiveEnd, i = n.index, s = function AC() { return O.lFrame.currentDirectiveIndex }(); try { dn(i); for (let a = r; a < o; a++) { const u = e.data[a], l = t[a]; $a(a), (null !== u.hostBindings || 0 !== u.hostVars || null !== u.hostAttrs) && Op(u, l) } } finally { dn(-1), $a(s) } }(e, t, n)) } function rl(e, t, n = ut) { const r = t.localNames; if (null !== r) { let o = t.index + 1; for (let i = 0; i < r.length; i += 2) { const s = r[i + 1], a = -1 === s ? n(t, e) : e[s]; e[o++] = a } } } function Tp(e) { const t = e.tView; return null === t || t.incompleteFirstPass ? e.tView = ol(1, null, e.template, e.decls, e.vars, e.directiveDefs, e.pipeDefs, e.viewQuery, e.schemas, e.consts) : t } function ol(e, t, n, r, o, i, s, a, u, l) { const c = 22 + r, d = c + o, f = function Kb(e, t) { const n = []; for (let r = 0; r < t; r++)n.push(r < e ? null : k); return n }(c, d), h = "function" == typeof l ? l() : l; return f[1] = { type: e, blueprint: f, template: n, queries: null, viewQuery: a, declTNode: t, data: f.slice().fill(null, c), bindingStartIndex: c, expandoStartIndex: d, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof i ? i() : i, pipeRegistry: "function" == typeof s ? s() : s, firstChild: null, schemas: u, consts: h, incompleteFirstPass: !1 } } function xp(e, t, n) { for (let r in e) if (e.hasOwnProperty(r)) { const o = e[r]; (n = null === n ? {} : n).hasOwnProperty(r) ? n[r].push(t, o) : n[r] = [t, o] } return n } function Rp(e, t) { const r = t.directiveEnd, o = e.data, i = t.attrs, s = []; let a = null, u = null; for (let l = t.directiveStart; l < r; l++) { const c = o[l], d = c.inputs, f = null === i || ep(t) ? null : l0(d, i); s.push(f), a = xp(d, l, a), u = xp(c.outputs, l, u) } null !== a && (a.hasOwnProperty("class") && (t.flags |= 16), a.hasOwnProperty("style") && (t.flags |= 32)), t.initialInputs = s, t.inputs = a, t.outputs = u } function rt(e, t, n, r, o, i, s, a) { const u = ut(t, n); let c, l = t.inputs; !a && null != l && (c = l[r]) ? (cl(e, n, c, r, o), Ci(t) && Np(n, t.index)) : 3 & t.type && (r = function Jb(e) { return "class" === e ? "className" : "for" === e ? "htmlFor" : "formaction" === e ? "formAction" : "innerHtml" === e ? "innerHTML" : "readonly" === e ? "readOnly" : "tabindex" === e ? "tabIndex" : e }(r), o = null != s ? s(o, t.value || "", r) : o, i.setProperty(u, r, o)) } function Np(e, t) { const n = et(t, e); 16 & n[2] || (n[2] |= 32) } function il(e, t, n, r) { let o = !1; if (pf()) { const i = function r0(e, t, n) { const r = e.directiveRegistry; let o = null; if (r) for (let i = 0; i < r.length; i++) { const s = r[i]; tp(n, s.selectors, !1) && (o || (o = []), Ni(io(n, t), e, s.type), vt(s) ? (Fp(e, n), o.unshift(s)) : o.push(s)) } return o }(e, t, n), s = null === r ? null : { "": -1 }; if (null !== i) { o = !0, kp(n, e.data.length, i.length); for (let c = 0; c < i.length; c++) { const d = i[c]; d.providersResolver && d.providersResolver(d) } let a = !1, u = !1, l = br(e, t, i.length, null); for (let c = 0; c < i.length; c++) { const d = i[c]; n.mergedAttrs = Ai(n.mergedAttrs, d.hostAttrs), Lp(e, n, t, l, d), s0(l, d, s), null !== d.contentQueries && (n.flags |= 8), (null !== d.hostBindings || null !== d.hostAttrs || 0 !== d.hostVars) && (n.flags |= 128); const f = d.type.prototype; !a && (f.ngOnChanges || f.ngOnInit || f.ngDoCheck) && ((e.preOrderHooks || (e.preOrderHooks = [])).push(n.index), a = !0), !u && (f.ngOnChanges || f.ngDoCheck) && ((e.preOrderCheckHooks || (e.preOrderCheckHooks = [])).push(n.index), u = !0), l++ } Rp(e, n) } s && function o0(e, t, n) { if (t) { const r = e.localNames = []; for (let o = 0; o < t.length; o += 2) { const i = n[t[o + 1]]; if (null == i) throw new E(-301, !1); r.push(t[o], i) } } }(n, r, s) } return n.mergedAttrs = Ai(n.mergedAttrs, n.attrs), o } function Pp(e, t, n, r, o, i) { const s = i.hostBindings; if (s) { let a = e.hostBindingOpCodes; null === a && (a = e.hostBindingOpCodes = []); const u = ~t.index; (function e0(e) { let t = e.length; for (; t > 0;) { const n = e[--t]; if ("number" == typeof n && n < 0) return n } return 0 })(a) != u && a.push(u), a.push(r, o, s) } } function Op(e, t) { null !== e.hostBindings && e.hostBindings(1, t) } function Fp(e, t) { t.flags |= 2, (e.components || (e.components = [])).push(t.index) } function s0(e, t, n) { if (n) { if (t.exportAs) for (let r = 0; r < t.exportAs.length; r++)n[t.exportAs[r]] = e; vt(t) && (n[""] = e) } } function kp(e, t, n) { e.flags |= 1, e.directiveStart = t, e.directiveEnd = t + n, e.providerIndexes = t } function Lp(e, t, n, r, o) { e.data[r] = o; const i = o.factory || (o.factory = Fn(o.type)), s = new ro(i, vt(o), I); e.blueprint[r] = s, n[r] = s, Pp(e, t, 0, r, br(e, n, o.hostVars, k), o) } function a0(e, t, n) { const r = ut(t, e), o = Tp(n), i = e[10], s = ns(e, es(e, o, null, n.onPush ? 32 : 16, r, t, i, i.createRenderer(r, n), null, null, null)); e[t.index] = s } function u0(e, t, n, r, o, i) { const s = i[t]; if (null !== s) { const a = r.setInput; for (let u = 0; u < s.length;) { const l = s[u++], c = s[u++], d = s[u++]; null !== a ? r.setInput(n, d, l, c) : n[c] = d } } } function l0(e, t) { let n = null, r = 0; for (; r < t.length;) { const o = t[r]; if (0 !== o) if (5 !== o) { if ("number" == typeof o) break; e.hasOwnProperty(o) && (null === n && (n = []), n.push(o, e[o], t[r + 1])), r += 2 } else r += 2; else r += 4 } return n } function jp(e, t, n, r) { return new Array(e, !0, !1, t, null, 0, r, n, null, null) } function f0(e, t) { const n = et(t, e); if (bi(n)) { const r = n[1]; 48 & n[2] ? ts(r, n, r.template, n[8]) : n[5] > 0 && al(n) } } function al(e) { for (let r = Au(e); null !== r; r = xu(r))for (let o = 10; o < r.length; o++) { const i = r[o]; if (bi(i)) if (512 & i[2]) { const s = i[1]; ts(s, i, s.template, i[8]) } else i[5] > 0 && al(i) } const n = e[1].components; if (null !== n) for (let r = 0; r < n.length; r++) { const o = et(n[r], e); bi(o) && o[5] > 0 && al(o) } } function h0(e, t) { const n = et(t, e), r = n[1]; (function p0(e, t) { for (let n = t.length; n < e.blueprint.length; n++)t.push(e.blueprint[n]) })(r, n), tl(r, n, n[8]) } function ns(e, t) { return e[13] ? e[14][4] = t : e[13] = t, e[14] = t, t } function rs(e, t, n, r = !0) { const o = t[10]; o.begin && o.begin(); try { ts(e, t, e.template, n) } catch (s) { throw r && function Bp(e, t) { const n = e[9], r = n ? n.get(Dr, null) : null; r && r.handleError(t) }(t, s), s } finally { o.end && o.end() } } function ll(e, t, n) { Ba(0), t(e, n) } function cl(e, t, n, r, o) { for (let i = 0; i < n.length;) { const s = n[i++], a = n[i++], u = t[s], l = e.data[s]; null !== l.setInput ? l.setInput(u, o, r, a) : u[a] = o } } function Yt(e, t, n) { const r = function Ei(e, t) { return fe(t[e]) }(t, e); !function Lh(e, t, n) { e.setValue(t, n) }(e[V], r, n) } function os(e, t, n) { let r = n ? e.styles : null, o = n ? e.classes : null, i = 0; if (null !== t) for (let s = 0; s < t.length; s++) { const a = t[s]; "number" == typeof a ? i = a : 1 == i ? o = _a(o, a) : 2 == i && (r = _a(r, a + ": " + t[++s] + ";")) } n ? e.styles = r : e.stylesWithoutHost = r, n ? e.classes = o : e.classesWithoutHost = o } function is(e, t, n, r, o = !1) { for (; null !== n;) { const i = t[n.index]; if (null !== i && r.push(fe(i)), yt(i)) for (let a = 10; a < i.length; a++) { const u = i[a], l = u[1].firstChild; null !== l && is(u[1], u, l, r) } const s = n.type; if (8 & s) is(e, t, n.child, r); else if (32 & s) { const a = Tu(n, t); let u; for (; u = a();)r.push(u) } else if (16 & s) { const a = Kh(t, n); if (Array.isArray(a)) r.push(...a); else { const u = bo(t[16]); is(u[1], u, a, r, !0) } } n = o ? n.projectionNext : n.next } return r } class So { constructor(t, n) { this._lView = t, this._cdRefInjectingView = n, this._appRef = null, this._attachedToViewContainer = !1 } get rootNodes() { const t = this._lView, n = t[1]; return is(n, t, n.firstChild, []) } get context() { return this._lView[8] } set context(t) { this._lView[8] = t } get destroyed() { return 128 == (128 & this._lView[2]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const t = this._lView[3]; if (yt(t)) { const n = t[8], r = n ? n.indexOf(this) : -1; r > -1 && (Pu(t, r), Oi(n, r)) } this._attachedToViewContainer = !1 } Vh(this._lView[1], this._lView) } onDestroy(t) { !function Ap(e, t, n, r) { const o = function Vp(e) { return e[7] || (e[7] = []) }(t); null === n ? o.push(r) : (o.push(n), e.firstCreatePass && function $p(e) { return e.cleanup || (e.cleanup = []) }(e).push(r, o.length - 1)) }(this._lView[1], this._lView, null, t) } markForCheck() { !function ul(e) { for (; e;) { e[2] |= 32; const t = bo(e); if (iC(e) && !t) return e; e = t } return null }(this._cdRefInjectingView || this._lView) } detach() { this._lView[2] &= -65 } reattach() { this._lView[2] |= 64 } detectChanges() { rs(this._lView[1], this._lView, this.context) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new E(902, !1); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function QE(e, t) { Io(e, t, t[V], 2, null, null) }(this._lView[1], this._lView) } attachToAppRef(t) { if (this._attachedToViewContainer) throw new E(902, !1); this._appRef = t } } class g0 extends So { constructor(t) { super(t), this._view = t } detectChanges() { const t = this._view; rs(t[1], t, t[8], !1) } checkNoChanges() { } get context() { return null } } class dl extends _o { constructor(t) { super(), this.ngModule = t } resolveComponentFactory(t) { const n = Q(t); return new Mo(n, this.ngModule) } } function Up(e) { const t = []; for (let n in e) e.hasOwnProperty(n) && t.push({ propName: e[n], templateName: n }); return t } class y0 { constructor(t, n) { this.injector = t, this.parentInjector = n } get(t, n, r) { const o = this.injector.get(t, vu, r); return o !== vu || n === vu ? o : this.parentInjector.get(t, n, r) } } class Mo extends wh { constructor(t, n) { super(), this.componentDef = t, this.ngModule = n, this.componentType = t.type, this.selector = function gb(e) { return e.map(pb).join(",") }(t.selectors), this.ngContentSelectors = t.ngContentSelectors ? t.ngContentSelectors : [], this.isBoundToModule = !!n } get inputs() { return Up(this.componentDef.inputs) } get outputs() { return Up(this.componentDef.outputs) } create(t, n, r, o) { let i = (o = o || this.ngModule) instanceof pn ? o : o?.injector; i && null !== this.componentDef.getStandaloneInjector && (i = this.componentDef.getStandaloneInjector(i) || i); const s = i ? new y0(t, i) : t, a = s.get(_h, null); if (null === a) throw new E(407, !1); const u = s.get(hE, null), l = a.createRenderer(null, this.componentDef), c = this.componentDef.selectors[0][0] || "div", d = r ? function Qb(e, t, n) { return e.selectRootElement(t, n === Nt.ShadowDom) }(l, r, this.componentDef.encapsulation) : Nu(l, c, function m0(e) { const t = e.toLowerCase(); return "svg" === t ? "svg" : "math" === t ? "math" : null }(c)), f = this.componentDef.onPush ? 288 : 272, h = ol(0, null, null, 1, 0, null, null, null, null, null), p = es(null, h, null, f, null, null, a, l, u, s, null); let g, y; Ua(p); try { const D = function w0(e, t, n, r, o, i) { const s = n[1]; n[22] = e; const u = Er(s, 22, 2, "#host", null), l = u.mergedAttrs = t.hostAttrs; null !== l && (os(u, l, !0), null !== e && (Ti(o, e, l), null !== u.classes && ju(o, e, u.classes), null !== u.styles && Jh(o, e, u.styles))); const c = r.createRenderer(e, t), d = es(n, Tp(t), null, t.onPush ? 32 : 16, n[22], u, r, c, i || null, null, null); return s.firstCreatePass && (Ni(io(u, n), s, t.type), Fp(s, u), kp(u, n.length, 1)), ns(n, d), n[22] = d }(d, this.componentDef, p, a, l); if (d) if (r) Ti(l, d, ["ng-version", pE.full]); else { const { attrs: w, classes: m } = function mb(e) { const t = [], n = []; let r = 1, o = 2; for (; r < e.length;) { let i = e[r]; if ("string" == typeof i) 2 === o ? "" !== i && t.push(i, e[++r]) : 8 === o && n.push(i); else { if (!Dt(o)) break; o = i } r++ } return { attrs: t, classes: n } }(this.componentDef.selectors[0]); w && Ti(l, d, w), m && m.length > 0 && ju(l, d, m.join(" ")) } if (y = ka(h, 22), void 0 !== n) { const w = y.projection = []; for (let m = 0; m < this.ngContentSelectors.length; m++) { const S = n[m]; w.push(null != S ? Array.from(S) : null) } } g = function C0(e, t, n, r) { const o = n[1], i = function Xb(e, t, n) { const r = De(); e.firstCreatePass && (n.providersResolver && n.providersResolver(n), Lp(e, r, t, br(e, t, 1, null), n), Rp(e, r)); const o = so(t, e, r.directiveStart, r); Pe(o, t); const i = ut(r, t); return i && Pe(i, t), o }(o, n, t); if (e[8] = n[8] = i, null !== r) for (const a of r) a(i, t); if (t.contentQueries) { const a = De(); t.contentQueries(1, i, a.directiveStart) } const s = De(); return !o.firstCreatePass || null === t.hostBindings && null === t.hostAttrs || (dn(s.index), Pp(n[1], s, 0, s.directiveStart, s.directiveEnd, t), Op(t, i)), i }(D, this.componentDef, p, [_0]), tl(h, p, null) } finally { za() } return new D0(this.componentType, g, vr(y, p), p, y) } } class D0 extends class aE { }{ constructor(t, n, r, o, i) { super(), this.location = r, this._rootLView = o, this._tNode = i, this.instance = n, this.hostView = this.changeDetectorRef = new g0(o), this.componentType = t } setInput(t, n) { const r = this._tNode.inputs; let o; if (null !== r && (o = r[t])) { const i = this._rootLView; cl(i[1], i, o, t, n), Np(i, this._tNode.index) } } get injector() { return new ur(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(t) { this.hostView.onDestroy(t) } } function _0() { const e = De(); Ii(v()[1], e) } let ss = null; function $n() { if (!ss) { const e = X.Symbol; if (e && e.iterator) ss = e.iterator; else { const t = Object.getOwnPropertyNames(Map.prototype); for (let n = 0; n < t.length; ++n) { const r = t[n]; "entries" !== r && "size" !== r && Map.prototype[r] === Map.prototype.entries && (ss = r) } } } return ss } function To(e) { return !!function hl(e) { return null !== e && ("function" == typeof e || "object" == typeof e) }(e) && (Array.isArray(e) || !(e instanceof Map) && $n() in e) } function Oe(e, t, n) { return !Object.is(e[t], n) && (e[t] = n, !0) } function Sr(e, t, n, r) { return Oe(e, ir(), n) ? t + F(n) + r : k } function gl(e, t, n) { const r = v(); return Oe(r, ir(), t) && rt(z(), se(), r, e, t, r[V], n, !1), gl } function ml(e, t, n, r, o) { const s = o ? "class" : "style"; cl(e, n, t.inputs[s], s, r) } function le(e, t, n, r) { const o = v(), i = z(), s = 22 + e, a = o[V], u = o[s] = Nu(a, t, function LC() { return O.lFrame.currentNamespace }()), l = i.firstCreatePass ? function L0(e, t, n, r, o, i, s) { const a = t.consts, l = Er(t, e, 2, o, cn(a, i)); return il(t, n, l, cn(a, s)), null !== l.attrs && os(l, l.attrs, !1), null !== l.mergedAttrs && os(l, l.mergedAttrs, !0), null !== t.queries && t.queries.elementStart(t, l), l }(s, i, o, 0, t, n, r) : i.data[s]; Pt(l, !0); const c = l.mergedAttrs; null !== c && Ti(a, u, c); const d = l.classes; null !== d && ju(a, u, d); const f = l.styles; return null !== f && Jh(a, u, f), 64 != (64 & l.flags) && Ki(i, o, u, l), 0 === function DC() { return O.lFrame.elementDepthCount }() && Pe(u, o), function wC() { O.lFrame.elementDepthCount++ }(), _i(l) && (nl(i, o, l), function Mp(e, t, n) { if (Ra(t)) { const o = t.directiveEnd; for (let i = t.directiveStart; i < o; i++) { const s = e.data[i]; s.contentQueries && s.contentQueries(1, n[i], i) } } }(i, l, o)), null !== r && rl(o, l), le } function pe() { let e = De(); ja() ? function Va() { O.lFrame.isParent = !1 }() : (e = e.parent, Pt(e, !1)); const t = e; !function CC() { O.lFrame.elementDepthCount-- }(); const n = z(); return n.firstCreatePass && (Ii(n, e), Ra(e) && n.queries.elementEnd(e)), null != t.classesWithoutHost && function BC(e) { return 0 != (16 & e.flags) }(t) && ml(n, t, v(), t.classesWithoutHost, !0), null != t.stylesWithoutHost && function UC(e) { return 0 != (32 & e.flags) }(t) && ml(n, t, v(), t.stylesWithoutHost, !1), pe } function Ct(e, t, n, r) { return le(e, t, n, r), pe(), Ct } function us(e) { return !!e && "function" == typeof e.then } const og = function rg(e) { return !!e && "function" == typeof e.subscribe }; function Dl(e, t, n) { return wl(e, "", t, "", n), Dl } function wl(e, t, n, r, o) { const i = v(), s = Sr(i, t, n, r); return s !== k && rt(z(), se(), i, e, s, i[V], o, !1), wl } function dt(e, t = "") { const n = v(), r = z(), o = e + 22, i = r.firstCreatePass ? Er(r, o, 1, t, null) : r.data[o], s = n[o] = function Ru(e, t) { return e.createText(t) }(n[V], t); Ki(r, n, s, i), Pt(i, !1) } function ds(e) { return Ro("", e, ""), ds } function Ro(e, t, n) { const r = v(), o = Sr(r, e, t, n); return o !== k && Yt(r, $e(), o), Ro } const kr = "en-US"; let Xg = kr; class Un { } class Im { } class Sm extends Un { constructor(t, n) { super(), this._parent = n, this._bootstrapComponents = [], this.destroyCbs = [], this.componentFactoryResolver = new dl(this); const r = Ye(t); this._bootstrapComponents = Zt(r.bootstrap), this._r3Injector = up(t, n, [{ provide: Un, useValue: this }, { provide: _o, useValue: this.componentFactoryResolver }], J(t), new Set(["environment"])), this._r3Injector.resolveInjectorInitializers(), this.instance = this._r3Injector.get(t) } get injector() { return this._r3Injector } destroy() { const t = this._r3Injector; !t.destroyed && t.destroy(), this.destroyCbs.forEach(n => n()), this.destroyCbs = null } onDestroy(t) { this.destroyCbs.push(t) } } class Tl extends Im { constructor(t) { super(), this.moduleType = t } create(t) { return new Sm(this.moduleType, t) } } class AS extends Un { constructor(t, n, r) { super(), this.componentFactoryResolver = new dl(this), this.instance = null; const o = new vh([...t, { provide: Un, useValue: this }, { provide: _o, useValue: this.componentFactoryResolver }], n || zi(), r, new Set(["environment"])); this.injector = o, o.resolveInjectorInitializers() } destroy() { this.injector.destroy() } onDestroy(t) { this.injector.onDestroy(t) } } function ms(e, t, n = null) { return new AS(e, t, n).injector } let xS = (() => { class e { constructor(n) { this._injector = n, this.cachedInjectors = new Map } getOrCreateStandaloneInjector(n) { if (!n.standalone) return null; if (!this.cachedInjectors.has(n.id)) { const r = ph(0, n.type), o = r.length > 0 ? ms([r], this._injector, `Standalone[${n.type.name}]`) : null; this.cachedInjectors.set(n.id, o) } return this.cachedInjectors.get(n.id) } ngOnDestroy() { try { for (const n of this.cachedInjectors.values()) null !== n && n.destroy() } finally { this.cachedInjectors.clear() } } } return e.\u0275prov = N({ token: e, providedIn: "environment", factory: () => new e(b(pn)) }), e })(); function Mm(e) { e.getStandaloneInjector = t => t.get(xS).getOrCreateStandaloneInjector(e) } function xl(e) { return t => { setTimeout(e, void 0, t) } } const Ue = class nM extends At { constructor(t = !1) { super(), this.__isAsync = t } emit(t) { super.next(t) } subscribe(t, n, r) { let o = t, i = n || (() => null), s = r; if (t && "object" == typeof t) { const u = t; o = u.next?.bind(u), i = u.error?.bind(u), s = u.complete?.bind(u) } this.__isAsync && (i = xl(i), o && (o = xl(o)), s && (s = xl(s))); const a = super.subscribe({ next: o, error: i, complete: s }); return t instanceof ot && t.add(a), a } }; let Xt = (() => { class e { } return e.__NG_ELEMENT_ID__ = sM, e })(); const oM = Xt, iM = class extends oM { constructor(t, n, r) { super(), this._declarationLView = t, this._declarationTContainer = n, this.elementRef = r } createEmbeddedView(t, n) { const r = this._declarationTContainer.tViews, o = es(this._declarationLView, r, t, 16, null, r.declTNode, null, null, null, null, n || null); o[17] = this._declarationLView[this._declarationTContainer.index]; const s = this._declarationLView[19]; return null !== s && (o[19] = s.createEmbeddedView(r)), tl(r, o, t), new So(o) } }; function sM() { return function ys(e, t) { return 4 & e.type ? new iM(t, e, vr(e, t)) : null }(De(), v()) } let bt = (() => { class e { } return e.__NG_ELEMENT_ID__ = aM, e })(); function aM() { return function Hm(e, t) { let n; const r = t[e.index]; if (yt(r)) n = r; else { let o; if (8 & e.type) o = fe(r); else { const i = t[V]; o = i.createComment(""); const s = ut(e, t); jn(i, qi(i, s), o, function nb(e, t) { return e.nextSibling(t) }(i, s), !1) } t[e.index] = n = jp(r, t, o, e), ns(t, n) } return new Vm(n, e, t) }(De(), v()) } const uM = bt, Vm = class extends uM { constructor(t, n, r) { super(), this._lContainer = t, this._hostTNode = n, this._hostLView = r } get element() { return vr(this._hostTNode, this._hostLView) } get injector() { return new ur(this._hostTNode, this._hostLView) } get parentInjector() { const t = Ri(this._hostTNode, this._hostLView); if (Af(t)) { const n = ar(t, this._hostLView), r = sr(t); return new ur(n[1].data[r + 8], n) } return new ur(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(t) { const n = $m(this._lContainer); return null !== n && n[t] || null } get length() { return this._lContainer.length - 10 } createEmbeddedView(t, n, r) { let o, i; "number" == typeof r ? o = r : null != r && (o = r.index, i = r.injector); const s = t.createEmbeddedView(n || {}, i); return this.insert(s, o), s } createComponent(t, n, r, o, i) { const s = t && !function lo(e) { return "function" == typeof e }(t); let a; if (s) a = n; else { const d = n || {}; a = d.index, r = d.injector, o = d.projectableNodes, i = d.environmentInjector || d.ngModuleRef } const u = s ? t : new Mo(Q(t)), l = r || this.parentInjector; if (!i && null == u.ngModule) { const f = (s ? l : this.parentInjector).get(pn, null); f && (i = f) } const c = u.create(l, o, void 0, i); return this.insert(c.hostView, a), c } insert(t, n) { const r = t._lView, o = r[1]; if (function vC(e) { return yt(e[3]) }(r)) { const c = this.indexOf(t); if (-1 !== c) this.detach(c); else { const d = r[3], f = new Vm(d, d[6], d[3]); f.detach(f.indexOf(t)) } } const i = this._adjustIndex(n), s = this._lContainer; !function JE(e, t, n, r) { const o = 10 + r, i = n.length; r > 0 && (n[o - 1][4] = t), r < i - 10 ? (t[4] = n[o], $f(n, 10 + r, t)) : (n.push(t), t[4] = null), t[3] = n; const s = t[17]; null !== s && n !== s && function YE(e, t) { const n = e[9]; t[16] !== t[3][3][16] && (e[2] = !0), null === n ? e[9] = [t] : n.push(t) }(s, t); const a = t[19]; null !== a && a.insertView(e), t[2] |= 64 }(o, r, s, i); const a = ku(i, s), u = r[V], l = qi(u, s[7]); return null !== l && function KE(e, t, n, r, o, i) { r[0] = o, r[6] = t, Io(e, r, n, 1, o, i) }(o, s[6], u, r, l, a), t.attachToViewContainerRef(), $f(Nl(s), i, t), t } move(t, n) { return this.insert(t, n) } indexOf(t) { const n = $m(this._lContainer); return null !== n ? n.indexOf(t) : -1 } remove(t) { const n = this._adjustIndex(t, -1), r = Pu(this._lContainer, n); r && (Oi(Nl(this._lContainer), n), Vh(r[1], r)) } detach(t) { const n = this._adjustIndex(t, -1), r = Pu(this._lContainer, n); return r && null != Oi(Nl(this._lContainer), n) ? new So(r) : null } _adjustIndex(t, n = 0) { return t ?? this.length + n } }; function $m(e) { return e[8] } function Nl(e) { return e[8] || (e[8] = []) } function Ds(...e) { } const ws = new P("Application Initializer"); let Cs = (() => { class e { constructor(n) { this.appInits = n, this.resolve = Ds, this.reject = Ds, this.initialized = !1, this.done = !1, this.donePromise = new Promise((r, o) => { this.resolve = r, this.reject = o }) } runInitializers() { if (this.initialized) return; const n = [], r = () => { this.done = !0, this.resolve() }; if (this.appInits) for (let o = 0; o < this.appInits.length; o++) { const i = this.appInits[o](); if (us(i)) n.push(i); else if (og(i)) { const s = new Promise((a, u) => { i.subscribe({ complete: a, error: u }) }); n.push(s) } } Promise.all(n).then(() => { r() }).catch(o => { this.reject(o) }), 0 === n.length && r(), this.initialized = !0 } } return e.\u0275fac = function (n) { return new (n || e)(b(ws, 8)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const $o = new P("AppId", { providedIn: "root", factory: function dy() { return `${Gl()}${Gl()}${Gl()}` } }); function Gl() { return String.fromCharCode(97 + Math.floor(25 * Math.random())) } const fy = new P("Platform Initializer"), Wl = new P("Platform ID", { providedIn: "platform", factory: () => "unknown" }), hy = new P("appBootstrapListener"); let jM = (() => { class e { log(n) { console.log(n) } warn(n) { console.warn(n) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(); const en = new P("LocaleId", { providedIn: "root", factory: () => ue(en, A.Optional | A.SkipSelf) || function VM() { return typeof $localize < "u" && $localize.locale || kr }() }); class HM { constructor(t, n) { this.ngModuleFactory = t, this.componentFactories = n } } let ql = (() => { class e { compileModuleSync(n) { return new Tl(n) } compileModuleAsync(n) { return Promise.resolve(this.compileModuleSync(n)) } compileModuleAndAllComponentsSync(n) { const r = this.compileModuleSync(n), i = Zt(Ye(n).declarations).reduce((s, a) => { const u = Q(a); return u && s.push(new Mo(u)), s }, []); return new HM(r, i) } compileModuleAndAllComponentsAsync(n) { return Promise.resolve(this.compileModuleAndAllComponentsSync(n)) } clearCache() { } clearCacheFor(n) { } getModuleId(n) { } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const zM = (() => Promise.resolve(0))(); function Kl(e) { typeof Zone > "u" ? zM.then(() => { e && e.apply(null, null) }) : Zone.current.scheduleMicroTask("scheduleMicrotask", e) } class _e { constructor({ enableLongStackTrace: t = !1, shouldCoalesceEventChangeDetection: n = !1, shouldCoalesceRunChangeDetection: r = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new Ue(!1), this.onMicrotaskEmpty = new Ue(!1), this.onStable = new Ue(!1), this.onError = new Ue(!1), typeof Zone > "u") throw new E(908, !1); Zone.assertZonePatched(); const o = this; if (o._nesting = 0, o._outer = o._inner = Zone.current, Zone.AsyncStackTaggingZoneSpec) { const i = Zone.AsyncStackTaggingZoneSpec; o._inner = o._inner.fork(new i("Angular")) } Zone.TaskTrackingZoneSpec && (o._inner = o._inner.fork(new Zone.TaskTrackingZoneSpec)), t && Zone.longStackTraceZoneSpec && (o._inner = o._inner.fork(Zone.longStackTraceZoneSpec)), o.shouldCoalesceEventChangeDetection = !r && n, o.shouldCoalesceRunChangeDetection = r, o.lastRequestAnimationFrameId = -1, o.nativeRequestAnimationFrame = function GM() { let e = X.requestAnimationFrame, t = X.cancelAnimationFrame; if (typeof Zone < "u" && e && t) { const n = e[Zone.__symbol__("OriginalDelegate")]; n && (e = n); const r = t[Zone.__symbol__("OriginalDelegate")]; r && (t = r) } return { nativeRequestAnimationFrame: e, nativeCancelAnimationFrame: t } }().nativeRequestAnimationFrame, function KM(e) { const t = () => { !function qM(e) { e.isCheckStableRunning || -1 !== e.lastRequestAnimationFrameId || (e.lastRequestAnimationFrameId = e.nativeRequestAnimationFrame.call(X, () => { e.fakeTopEventTask || (e.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { e.lastRequestAnimationFrameId = -1, Zl(e), e.isCheckStableRunning = !0, Ql(e), e.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), e.fakeTopEventTask.invoke() }), Zl(e)) }(e) }; e._inner = e._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (n, r, o, i, s, a) => { try { return my(e), n.invokeTask(o, i, s, a) } finally { (e.shouldCoalesceEventChangeDetection && "eventTask" === i.type || e.shouldCoalesceRunChangeDetection) && t(), yy(e) } }, onInvoke: (n, r, o, i, s, a, u) => { try { return my(e), n.invoke(o, i, s, a, u) } finally { e.shouldCoalesceRunChangeDetection && t(), yy(e) } }, onHasTask: (n, r, o, i) => { n.hasTask(o, i), r === o && ("microTask" == i.change ? (e._hasPendingMicrotasks = i.microTask, Zl(e), Ql(e)) : "macroTask" == i.change && (e.hasPendingMacrotasks = i.macroTask)) }, onHandleError: (n, r, o, i) => (n.handleError(o, i), e.runOutsideAngular(() => e.onError.emit(i)), !1) }) }(o) } static isInAngularZone() { return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!_e.isInAngularZone()) throw new E(909, !1) } static assertNotInAngularZone() { if (_e.isInAngularZone()) throw new E(909, !1) } run(t, n, r) { return this._inner.run(t, n, r) } runTask(t, n, r, o) { const i = this._inner, s = i.scheduleEventTask("NgZoneEvent: " + o, t, WM, Ds, Ds); try { return i.runTask(s, n, r) } finally { i.cancelTask(s) } } runGuarded(t, n, r) { return this._inner.runGuarded(t, n, r) } runOutsideAngular(t) { return this._outer.run(t) } } const WM = {}; function Ql(e) { if (0 == e._nesting && !e.hasPendingMicrotasks && !e.isStable) try { e._nesting++, e.onMicrotaskEmpty.emit(null) } finally { if (e._nesting--, !e.hasPendingMicrotasks) try { e.runOutsideAngular(() => e.onStable.emit(null)) } finally { e.isStable = !0 } } } function Zl(e) { e.hasPendingMicrotasks = !!(e._hasPendingMicrotasks || (e.shouldCoalesceEventChangeDetection || e.shouldCoalesceRunChangeDetection) && -1 !== e.lastRequestAnimationFrameId) } function my(e) { e._nesting++, e.isStable && (e.isStable = !1, e.onUnstable.emit(null)) } function yy(e) { e._nesting--, Ql(e) } class QM { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new Ue, this.onMicrotaskEmpty = new Ue, this.onStable = new Ue, this.onError = new Ue } run(t, n, r) { return t.apply(n, r) } runGuarded(t, n, r) { return t.apply(n, r) } runOutsideAngular(t) { return t() } runTask(t, n, r, o) { return t.apply(n, r) } } const vy = new P(""), _s = new P(""); let Xl, Jl = (() => { class e { constructor(n, r, o) { this._ngZone = n, this.registry = r, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, Xl || (function ZM(e) { Xl = e }(o), o.addToWindow(r)), this._watchAngularEvents(), n.run(() => { this.taskTrackingZone = typeof Zone > "u" ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { _e.assertNotInAngularZone(), Kl(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) Kl(() => { for (; 0 !== this._callbacks.length;) { let n = this._callbacks.pop(); clearTimeout(n.timeoutId), n.doneCb(this._didWork) } this._didWork = !1 }); else { let n = this.getPendingTasks(); this._callbacks = this._callbacks.filter(r => !r.updateCb || !r.updateCb(n) || (clearTimeout(r.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(n => ({ source: n.source, creationLocation: n.creationLocation, data: n.data })) : [] } addCallback(n, r, o) { let i = -1; r && r > 0 && (i = setTimeout(() => { this._callbacks = this._callbacks.filter(s => s.timeoutId !== i), n(this._didWork, this.getPendingTasks()) }, r)), this._callbacks.push({ doneCb: n, timeoutId: i, updateCb: o }) } whenStable(n, r, o) { if (o && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(n, r, o), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } registerApplication(n) { this.registry.registerApplication(n, this) } unregisterApplication(n) { this.registry.unregisterApplication(n) } findProviders(n, r, o) { return [] } } return e.\u0275fac = function (n) { return new (n || e)(b(_e), b(Yl), b(_s)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(), Yl = (() => { class e { constructor() { this._applications = new Map } registerApplication(n, r) { this._applications.set(n, r) } unregisterApplication(n) { this._applications.delete(n) } unregisterAllApplications() { this._applications.clear() } getTestability(n) { return this._applications.get(n) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(n, r = !0) { return Xl?.findTestabilityInTree(this, n, r) ?? null } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(), vn = null; const Dy = new P("AllowMultipleToken"), ec = new P("PlatformDestroyListeners"); class wy { constructor(t, n) { this.name = t, this.token = n } } function _y(e, t, n = []) { const r = `Platform: ${t}`, o = new P(r); return (i = []) => { let s = tc(); if (!s || s.injector.get(Dy, !1)) { const a = [...n, ...i, { provide: o, useValue: !0 }]; e ? e(a) : function XM(e) { if (vn && !vn.get(Dy, !1)) throw new E(400, !1); vn = e; const t = e.get(by); (function Cy(e) { const t = e.get(fy, null); t && t.forEach(n => n()) })(e) }(function Ey(e = [], t) { return lt.create({ name: t, providers: [{ provide: pu, useValue: "platform" }, { provide: ec, useValue: new Set([() => vn = null]) }, ...e] }) }(a, r)) } return function tT(e) { const t = tc(); if (!t) throw new E(401, !1); return t }() } } function tc() { return vn?.get(by) ?? null } let by = (() => { class e { constructor(n) { this._injector = n, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(n, r) { const o = function Sy(e, t) { let n; return n = "noop" === e ? new QM : ("zone.js" === e ? void 0 : e) || new _e(t), n }(r?.ngZone, function Iy(e) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: !(!e || !e.ngZoneEventCoalescing) || !1, shouldCoalesceRunChangeDetection: !(!e || !e.ngZoneRunCoalescing) || !1 } }(r)), i = [{ provide: _e, useValue: o }]; return o.run(() => { const s = lt.create({ providers: i, parent: this.injector, name: n.moduleType.name }), a = n.create(s), u = a.injector.get(Dr, null); if (!u) throw new E(402, !1); return o.runOutsideAngular(() => { const l = o.onError.subscribe({ next: c => { u.handleError(c) } }); a.onDestroy(() => { bs(this._modules, a), l.unsubscribe() }) }), function My(e, t, n) { try { const r = n(); return us(r) ? r.catch(o => { throw t.runOutsideAngular(() => e.handleError(o)), o }) : r } catch (r) { throw t.runOutsideAngular(() => e.handleError(r)), r } }(u, o, () => { const l = a.injector.get(Cs); return l.runInitializers(), l.donePromise.then(() => (function em(e) { Je(e, "Expected localeId to be defined"), "string" == typeof e && (Xg = e.toLowerCase().replace(/_/g, "-")) }(a.injector.get(en, kr) || kr), this._moduleDoBootstrap(a), a)) }) }) } bootstrapModule(n, r = []) { const o = Ty({}, r); return function JM(e, t, n) { const r = new Tl(n); return Promise.resolve(r) }(0, 0, n).then(i => this.bootstrapModuleFactory(i, o)) } _moduleDoBootstrap(n) { const r = n.injector.get(Es); if (n._bootstrapComponents.length > 0) n._bootstrapComponents.forEach(o => r.bootstrap(o)); else { if (!n.instance.ngDoBootstrap) throw new E(403, !1); n.instance.ngDoBootstrap(r) } this._modules.push(n) } onDestroy(n) { this._destroyListeners.push(n) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new E(404, !1); this._modules.slice().forEach(r => r.destroy()), this._destroyListeners.forEach(r => r()); const n = this._injector.get(ec, null); n && (n.forEach(r => r()), n.clear()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return e.\u0275fac = function (n) { return new (n || e)(b(lt)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "platform" }), e })(); function Ty(e, t) { return Array.isArray(t) ? t.reduce(Ty, e) : { ...e, ...t } } let Es = (() => { class e { constructor(n, r, o) { this._zone = n, this._injector = r, this._exceptionHandler = o, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this._destroyed = !1, this._destroyListeners = [], this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({ next: () => { this._zone.run(() => { this.tick() }) } }); const i = new de(a => { this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular(() => { a.next(this._stable), a.complete() }) }), s = new de(a => { let u; this._zone.runOutsideAngular(() => { u = this._zone.onStable.subscribe(() => { _e.assertNotInAngularZone(), Kl(() => { !this._stable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks && (this._stable = !0, a.next(!0)) }) }) }); const l = this._zone.onUnstable.subscribe(() => { _e.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular(() => { a.next(!1) })) }); return () => { u.unsubscribe(), l.unsubscribe() } }); this.isStable = function $w(...e) { const t = Zr(e), n = function Pw(e, t) { return "number" == typeof Da(e) ? e.pop() : t }(e, 1 / 0), r = e; return r.length ? 1 === r.length ? xt(r[0]) : Yn(n)(ve(r, t)) : Bt }(i, s.pipe(function Hw(e = {}) { const { connector: t = (() => new At), resetOnError: n = !0, resetOnComplete: r = !0, resetOnRefCountZero: o = !0 } = e; return i => { let s, a, u, l = 0, c = !1, d = !1; const f = () => { a?.unsubscribe(), a = void 0 }, h = () => { f(), s = u = void 0, c = d = !1 }, p = () => { const g = s; h(), g?.unsubscribe() }; return be((g, y) => { l++, !d && !c && f(); const D = u = u ?? t(); y.add(() => { l--, 0 === l && !d && !c && (a = wa(p, o)) }), D.subscribe(y), !s && l > 0 && (s = new Qr({ next: w => D.next(w), error: w => { d = !0, f(), a = wa(h, n, w), D.error(w) }, complete: () => { c = !0, f(), a = wa(h, r), D.complete() } }), xt(g).subscribe(s)) })(i) } }())) } get destroyed() { return this._destroyed } get injector() { return this._injector } bootstrap(n, r) { const o = n instanceof wh; if (!this._injector.get(Cs).done) throw !o && function er(e) { const t = Q(e) || Le(e) || je(e); return null !== t && t.standalone }(n), new E(405, false); let s; s = o ? n : this._injector.get(_o).resolveComponentFactory(n), this.componentTypes.push(s.componentType); const a = function YM(e) { return e.isBoundToModule }(s) ? void 0 : this._injector.get(Un), l = s.create(lt.NULL, [], r || s.selector, a), c = l.location.nativeElement, d = l.injector.get(vy, null); return d?.registerApplication(c), l.onDestroy(() => { this.detachView(l.hostView), bs(this.components, l), d?.unregisterApplication(c) }), this._loadComponent(l), l } tick() { if (this._runningTick) throw new E(101, !1); try { this._runningTick = !0; for (let n of this._views) n.detectChanges() } catch (n) { this._zone.runOutsideAngular(() => this._exceptionHandler.handleError(n)) } finally { this._runningTick = !1 } } attachView(n) { const r = n; this._views.push(r), r.attachToAppRef(this) } detachView(n) { const r = n; bs(this._views, r), r.detachFromAppRef() } _loadComponent(n) { this.attachView(n.hostView), this.tick(), this.components.push(n), this._injector.get(hy, []).concat(this._bootstrapListeners).forEach(o => o(n)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(n => n()), this._views.slice().forEach(n => n.destroy()), this._onMicrotaskEmptySubscription.unsubscribe() } finally { this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = [] } } onDestroy(n) { return this._destroyListeners.push(n), () => bs(this._destroyListeners, n) } destroy() { if (this._destroyed) throw new E(406, !1); const n = this._injector; n.destroy && !n.destroyed && n.destroy() } get viewCount() { return this._views.length } warnIfDestroyed() { } } return e.\u0275fac = function (n) { return new (n || e)(b(_e), b(pn), b(Dr)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function bs(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } let xy = !0, nc = (() => { class e { } return e.__NG_ELEMENT_ID__ = oT, e })(); function oT(e) { return function iT(e, t, n) { if (Ci(e) && !n) { const r = et(e.index, t); return new So(r, r) } return 47 & e.type ? new So(t[16], t) : null }(De(), v(), 16 == (16 & e)) } class Fy { constructor() { } supports(t) { return To(t) } create(t) { return new dT(t) } } const cT = (e, t) => t; class dT { constructor(t) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = t || cT } forEachItem(t) { let n; for (n = this._itHead; null !== n; n = n._next)t(n) } forEachOperation(t) { let n = this._itHead, r = this._removalsHead, o = 0, i = null; for (; n || r;) { const s = !r || n && n.currentIndex < Ly(r, o, i) ? n : r, a = Ly(s, o, i), u = s.currentIndex; if (s === r) o--, r = r._nextRemoved; else if (n = n._next, null == s.previousIndex) o++; else { i || (i = []); const l = a - o, c = u - o; if (l != c) { for (let f = 0; f < l; f++) { const h = f < i.length ? i[f] : i[f] = 0, p = h + f; c <= p && p < l && (i[f] = h + 1) } i[s.previousIndex] = c - l } } a !== u && t(s, a, u) } } forEachPreviousItem(t) { let n; for (n = this._previousItHead; null !== n; n = n._nextPrevious)t(n) } forEachAddedItem(t) { let n; for (n = this._additionsHead; null !== n; n = n._nextAdded)t(n) } forEachMovedItem(t) { let n; for (n = this._movesHead; null !== n; n = n._nextMoved)t(n) } forEachRemovedItem(t) { let n; for (n = this._removalsHead; null !== n; n = n._nextRemoved)t(n) } forEachIdentityChange(t) { let n; for (n = this._identityChangesHead; null !== n; n = n._nextIdentityChange)t(n) } diff(t) { if (null == t && (t = []), !To(t)) throw new E(900, !1); return this.check(t) ? this : null } onDestroy() { } check(t) { this._reset(); let o, i, s, n = this._itHead, r = !1; if (Array.isArray(t)) { this.length = t.length; for (let a = 0; a < this.length; a++)i = t[a], s = this._trackByFn(a, i), null !== n && Object.is(n.trackById, s) ? (r && (n = this._verifyReinsertion(n, i, s, a)), Object.is(n.item, i) || this._addIdentityChange(n, i)) : (n = this._mismatch(n, i, s, a), r = !0), n = n._next } else o = 0, function R0(e, t) { if (Array.isArray(e)) for (let n = 0; n < e.length; n++)t(e[n]); else { const n = e[$n()](); let r; for (; !(r = n.next()).done;)t(r.value) } }(t, a => { s = this._trackByFn(o, a), null !== n && Object.is(n.trackById, s) ? (r && (n = this._verifyReinsertion(n, a, s, o)), Object.is(n.item, a) || this._addIdentityChange(n, a)) : (n = this._mismatch(n, a, s, o), r = !0), n = n._next, o++ }), this.length = o; return this._truncate(n), this.collection = t, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let t; for (t = this._previousItHead = this._itHead; null !== t; t = t._next)t._nextPrevious = t._next; for (t = this._additionsHead; null !== t; t = t._nextAdded)t.previousIndex = t.currentIndex; for (this._additionsHead = this._additionsTail = null, t = this._movesHead; null !== t; t = t._nextMoved)t.previousIndex = t.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(t, n, r, o) { let i; return null === t ? i = this._itTail : (i = t._prev, this._remove(t)), null !== (t = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null)) ? (Object.is(t.item, n) || this._addIdentityChange(t, n), this._reinsertAfter(t, i, o)) : null !== (t = null === this._linkedRecords ? null : this._linkedRecords.get(r, o)) ? (Object.is(t.item, n) || this._addIdentityChange(t, n), this._moveAfter(t, i, o)) : t = this._addAfter(new fT(n, r), i, o), t } _verifyReinsertion(t, n, r, o) { let i = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(r, null); return null !== i ? t = this._reinsertAfter(i, t._prev, o) : t.currentIndex != o && (t.currentIndex = o, this._addToMoves(t, o)), t } _truncate(t) { for (; null !== t;) { const n = t._next; this._addToRemovals(this._unlink(t)), t = n } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(t, n, r) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(t); const o = t._prevRemoved, i = t._nextRemoved; return null === o ? this._removalsHead = i : o._nextRemoved = i, null === i ? this._removalsTail = o : i._prevRemoved = o, this._insertAfter(t, n, r), this._addToMoves(t, r), t } _moveAfter(t, n, r) { return this._unlink(t), this._insertAfter(t, n, r), this._addToMoves(t, r), t } _addAfter(t, n, r) { return this._insertAfter(t, n, r), this._additionsTail = null === this._additionsTail ? this._additionsHead = t : this._additionsTail._nextAdded = t, t } _insertAfter(t, n, r) { const o = null === n ? this._itHead : n._next; return t._next = o, t._prev = n, null === o ? this._itTail = t : o._prev = t, null === n ? this._itHead = t : n._next = t, null === this._linkedRecords && (this._linkedRecords = new ky), this._linkedRecords.put(t), t.currentIndex = r, t } _remove(t) { return this._addToRemovals(this._unlink(t)) } _unlink(t) { null !== this._linkedRecords && this._linkedRecords.remove(t); const n = t._prev, r = t._next; return null === n ? this._itHead = r : n._next = r, null === r ? this._itTail = n : r._prev = n, t } _addToMoves(t, n) { return t.previousIndex === n || (this._movesTail = null === this._movesTail ? this._movesHead = t : this._movesTail._nextMoved = t), t } _addToRemovals(t) { return null === this._unlinkedRecords && (this._unlinkedRecords = new ky), this._unlinkedRecords.put(t), t.currentIndex = null, t._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = t, t._prevRemoved = null) : (t._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = t), t } _addIdentityChange(t, n) { return t.item = n, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = t : this._identityChangesTail._nextIdentityChange = t, t } } class fT { constructor(t, n) { this.item = t, this.trackById = n, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class hT { constructor() { this._head = null, this._tail = null } add(t) { null === this._head ? (this._head = this._tail = t, t._nextDup = null, t._prevDup = null) : (this._tail._nextDup = t, t._prevDup = this._tail, t._nextDup = null, this._tail = t) } get(t, n) { let r; for (r = this._head; null !== r; r = r._nextDup)if ((null === n || n <= r.currentIndex) && Object.is(r.trackById, t)) return r; return null } remove(t) { const n = t._prevDup, r = t._nextDup; return null === n ? this._head = r : n._nextDup = r, null === r ? this._tail = n : r._prevDup = n, null === this._head } } class ky { constructor() { this.map = new Map } put(t) { const n = t.trackById; let r = this.map.get(n); r || (r = new hT, this.map.set(n, r)), r.add(t) } get(t, n) { const o = this.map.get(t); return o ? o.get(t, n) : null } remove(t) { const n = t.trackById; return this.map.get(n).remove(t) && this.map.delete(n), t } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function Ly(e, t, n) { const r = e.previousIndex; if (null === r) return r; let o = 0; return n && r < n.length && (o = n[r]), r + t + o } function Vy() { return new Ms([new Fy]) } let Ms = (() => { class e { constructor(n) { this.factories = n } static create(n, r) { if (null != r) { const o = r.factories.slice(); n = n.concat(o) } return new e(n) } static extend(n) { return { provide: e, useFactory: r => e.create(n, r || Vy()), deps: [[e, new mo, new go]] } } find(n) { const r = this.factories.find(o => o.supports(n)); if (null != r) return r; throw new E(901, !1) } } return e.\u0275prov = N({ token: e, providedIn: "root", factory: Vy }), e })(); const vT = _y(null, "core", []); let DT = (() => { class e { constructor(n) { } } return e.\u0275fac = function (n) { return new (n || e)(b(Es)) }, e.\u0275mod = Gt({ type: e }), e.\u0275inj = Rt({}), e })(), Ts = null; function Dn() { return Ts } const Ge = new P("DocumentToken"); let ac = (() => { class e { historyGo(n) { throw new Error("Not implemented") } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: function () { return function ET() { return b(Hy) }() }, providedIn: "platform" }), e })(); const bT = new P("Location Initialized"); let Hy = (() => { class e extends ac { constructor(n) { super(), this._doc = n, this._init() } _init() { this.location = window.location, this._history = window.history } getBaseHrefFromDOM() { return Dn().getBaseHref(this._doc) } onPopState(n) { const r = Dn().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("popstate", n, !1), () => r.removeEventListener("popstate", n) } onHashChange(n) { const r = Dn().getGlobalEventTarget(this._doc, "window"); return r.addEventListener("hashchange", n, !1), () => r.removeEventListener("hashchange", n) } get href() { return this.location.href } get protocol() { return this.location.protocol } get hostname() { return this.location.hostname } get port() { return this.location.port } get pathname() { return this.location.pathname } get search() { return this.location.search } get hash() { return this.location.hash } set pathname(n) { this.location.pathname = n } pushState(n, r, o) { By() ? this._history.pushState(n, r, o) : this.location.hash = o } replaceState(n, r, o) { By() ? this._history.replaceState(n, r, o) : this.location.hash = o } forward() { this._history.forward() } back() { this._history.back() } historyGo(n = 0) { this._history.go(n) } getState() { return this._history.state } } return e.\u0275fac = function (n) { return new (n || e)(b(Ge)) }, e.\u0275prov = N({ token: e, factory: function () { return function IT() { return new Hy(b(Ge)) }() }, providedIn: "platform" }), e })(); function By() { return !!window.history.pushState } function uc(e, t) { if (0 == e.length) return t; if (0 == t.length) return e; let n = 0; return e.endsWith("/") && n++, t.startsWith("/") && n++, 2 == n ? e + t.substring(1) : 1 == n ? e + t : e + "/" + t } function Uy(e) { const t = e.match(/#|\?|$/), n = t && t.index || e.length; return e.slice(0, n - ("/" === e[n - 1] ? 1 : 0)) + e.slice(n) } function nn(e) { return e && "?" !== e[0] ? "?" + e : e } let Gn = (() => { class e { historyGo(n) { throw new Error("Not implemented") } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: function () { return ue(Gy) }, providedIn: "root" }), e })(); const zy = new P("appBaseHref"); let Gy = (() => { class e extends Gn { constructor(n, r) { super(), this._platformLocation = n, this._removeListenerFns = [], this._baseHref = r ?? this._platformLocation.getBaseHrefFromDOM() ?? ue(Ge).location?.origin ?? "" } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(n) { this._removeListenerFns.push(this._platformLocation.onPopState(n), this._platformLocation.onHashChange(n)) } getBaseHref() { return this._baseHref } prepareExternalUrl(n) { return uc(this._baseHref, n) } path(n = !1) { const r = this._platformLocation.pathname + nn(this._platformLocation.search), o = this._platformLocation.hash; return o && n ? `${r}${o}` : r } pushState(n, r, o, i) { const s = this.prepareExternalUrl(o + nn(i)); this._platformLocation.pushState(n, r, s) } replaceState(n, r, o, i) { const s = this.prepareExternalUrl(o + nn(i)); this._platformLocation.replaceState(n, r, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(n = 0) { this._platformLocation.historyGo?.(n) } } return e.\u0275fac = function (n) { return new (n || e)(b(ac), b(zy, 8)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(), ST = (() => { class e extends Gn { constructor(n, r) { super(), this._platformLocation = n, this._baseHref = "", this._removeListenerFns = [], null != r && (this._baseHref = r) } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(n) { this._removeListenerFns.push(this._platformLocation.onPopState(n), this._platformLocation.onHashChange(n)) } getBaseHref() { return this._baseHref } path(n = !1) { let r = this._platformLocation.hash; return null == r && (r = "#"), r.length > 0 ? r.substring(1) : r } prepareExternalUrl(n) { const r = uc(this._baseHref, n); return r.length > 0 ? "#" + r : r } pushState(n, r, o, i) { let s = this.prepareExternalUrl(o + nn(i)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.pushState(n, r, s) } replaceState(n, r, o, i) { let s = this.prepareExternalUrl(o + nn(i)); 0 == s.length && (s = this._platformLocation.pathname), this._platformLocation.replaceState(n, r, s) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(n = 0) { this._platformLocation.historyGo?.(n) } } return e.\u0275fac = function (n) { return new (n || e)(b(ac), b(zy, 8)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(), lc = (() => { class e { constructor(n) { this._subject = new Ue, this._urlChangeListeners = [], this._urlChangeSubscription = null, this._locationStrategy = n; const r = this._locationStrategy.getBaseHref(); this._baseHref = Uy(Wy(r)), this._locationStrategy.onPopState(o => { this._subject.emit({ url: this.path(!0), pop: !0, state: o.state, type: o.type }) }) } ngOnDestroy() { this._urlChangeSubscription?.unsubscribe(), this._urlChangeListeners = [] } path(n = !1) { return this.normalize(this._locationStrategy.path(n)) } getState() { return this._locationStrategy.getState() } isCurrentPathEqualTo(n, r = "") { return this.path() == this.normalize(n + nn(r)) } normalize(n) { return e.stripTrailingSlash(function TT(e, t) { return e && t.startsWith(e) ? t.substring(e.length) : t }(this._baseHref, Wy(n))) } prepareExternalUrl(n) { return n && "/" !== n[0] && (n = "/" + n), this._locationStrategy.prepareExternalUrl(n) } go(n, r = "", o = null) { this._locationStrategy.pushState(o, "", n, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(n + nn(r)), o) } replaceState(n, r = "", o = null) { this._locationStrategy.replaceState(o, "", n, r), this._notifyUrlChangeListeners(this.prepareExternalUrl(n + nn(r)), o) } forward() { this._locationStrategy.forward() } back() { this._locationStrategy.back() } historyGo(n = 0) { this._locationStrategy.historyGo?.(n) } onUrlChange(n) { return this._urlChangeListeners.push(n), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(r => { this._notifyUrlChangeListeners(r.url, r.state) })), () => { const r = this._urlChangeListeners.indexOf(n); this._urlChangeListeners.splice(r, 1), 0 === this._urlChangeListeners.length && (this._urlChangeSubscription?.unsubscribe(), this._urlChangeSubscription = null) } } _notifyUrlChangeListeners(n = "", r) { this._urlChangeListeners.forEach(o => o(n, r)) } subscribe(n, r, o) { return this._subject.subscribe({ next: n, error: r, complete: o }) } } return e.normalizeQueryParams = nn, e.joinWithSlash = uc, e.stripTrailingSlash = Uy, e.\u0275fac = function (n) { return new (n || e)(b(Gn)) }, e.\u0275prov = N({ token: e, factory: function () { return function MT() { return new lc(b(Gn)) }() }, providedIn: "root" }), e })(); function Wy(e) { return e.replace(/\/index.html$/, "") } function tv(e, t) { t = encodeURIComponent(t); for (const n of e.split(";")) { const r = n.indexOf("="), [o, i] = -1 == r ? [n, ""] : [n.slice(0, r), n.slice(r + 1)]; if (o.trim() === t) return decodeURIComponent(i) } return null } class hA { constructor(t, n, r, o) { this.$implicit = t, this.ngForOf = n, this.index = r, this.count = o } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let ov = (() => { class e { constructor(n, r, o) { this._viewContainer = n, this._template = r, this._differs = o, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForOf(n) { this._ngForOf = n, this._ngForOfDirty = !0 } set ngForTrackBy(n) { this._trackByFn = n } get ngForTrackBy() { return this._trackByFn } set ngForTemplate(n) { n && (this._template = n) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const n = this._ngForOf; !this._differ && n && (this._differ = this._differs.find(n).create(this.ngForTrackBy)) } if (this._differ) { const n = this._differ.diff(this._ngForOf); n && this._applyChanges(n) } } _applyChanges(n) { const r = this._viewContainer; n.forEachOperation((o, i, s) => { if (null == o.previousIndex) r.createEmbeddedView(this._template, new hA(o.item, this._ngForOf, -1, -1), null === s ? void 0 : s); else if (null == s) r.remove(null === i ? void 0 : i); else if (null !== i) { const a = r.get(i); r.move(a, s), iv(a, o) } }); for (let o = 0, i = r.length; o < i; o++) { const a = r.get(o).context; a.index = o, a.count = i, a.ngForOf = this._ngForOf } n.forEachIdentityChange(o => { iv(r.get(o.currentIndex), o) }) } static ngTemplateContextGuard(n, r) { return !0 } } return e.\u0275fac = function (n) { return new (n || e)(I(bt), I(Xt), I(Ms)) }, e.\u0275dir = xe({ type: e, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" }, standalone: !0 }), e })(); function iv(e, t) { e.context.$implicit = t.item } let UA = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = Gt({ type: e }), e.\u0275inj = Rt({}), e })(); let qA = (() => { class e { } return e.\u0275prov = N({ token: e, providedIn: "root", factory: () => new KA(b(Ge), window) }), e })(); class KA { constructor(t, n) { this.document = t, this.window = n, this.offset = () => [0, 0] } setOffset(t) { this.offset = Array.isArray(t) ? () => t : t } getScrollPosition() { return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0] } scrollToPosition(t) { this.supportsScrolling() && this.window.scrollTo(t[0], t[1]) } scrollToAnchor(t) { if (!this.supportsScrolling()) return; const n = function QA(e, t) { const n = e.getElementById(t) || e.getElementsByName(t)[0]; if (n) return n; if ("function" == typeof e.createTreeWalker && e.body && (e.body.createShadowRoot || e.body.attachShadow)) { const r = e.createTreeWalker(e.body, NodeFilter.SHOW_ELEMENT); let o = r.currentNode; for (; o;) { const i = o.shadowRoot; if (i) { const s = i.getElementById(t) || i.querySelector(`[name="${t}"]`); if (s) return s } o = r.nextNode() } } return null }(this.document, t); n && (this.scrollToElement(n), n.focus()) } setHistoryScrollRestoration(t) { if (this.supportScrollRestoration()) { const n = this.window.history; n && n.scrollRestoration && (n.scrollRestoration = t) } } scrollToElement(t) { const n = t.getBoundingClientRect(), r = n.left + this.window.pageXOffset, o = n.top + this.window.pageYOffset, i = this.offset(); this.window.scrollTo(r - i[0], o - i[1]) } supportScrollRestoration() { try { if (!this.supportsScrolling()) return !1; const t = cv(this.window.history) || cv(Object.getPrototypeOf(this.window.history)); return !(!t || !t.writable && !t.set) } catch { return !1 } } supportsScrolling() { try { return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window } catch { return !1 } } } function cv(e) { return Object.getOwnPropertyDescriptor(e, "scrollRestoration") } class dv { } class Ic extends class hx extends class _T { }{ constructor() { super(...arguments), this.supportsDOMEvents = !0 } }{ static makeCurrent() { !function CT(e) { Ts || (Ts = e) }(new Ic) } onAndCancel(t, n, r) { return t.addEventListener(n, r, !1), () => { t.removeEventListener(n, r, !1) } } dispatchEvent(t, n) { t.dispatchEvent(n) } remove(t) { t.parentNode && t.parentNode.removeChild(t) } createElement(t, n) { return (n = n || this.getDefaultDocument()).createElement(t) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(t) { return t.nodeType === Node.ELEMENT_NODE } isShadowRoot(t) { return t instanceof DocumentFragment } getGlobalEventTarget(t, n) { return "window" === n ? window : "document" === n ? t : "body" === n ? t.body : null } getBaseHref(t) { const n = function px() { return Go = Go || document.querySelector("base"), Go ? Go.getAttribute("href") : null }(); return null == n ? null : function gx(e) { Vs = Vs || document.createElement("a"), Vs.setAttribute("href", e); const t = Vs.pathname; return "/" === t.charAt(0) ? t : `/${t}` }(n) } resetBaseElement() { Go = null } getUserAgent() { return window.navigator.userAgent } getCookie(t) { return tv(document.cookie, t) } } let Vs, Go = null; const gv = new P("TRANSITION_ID"), yx = [{ provide: ws, useFactory: function mx(e, t, n) { return () => { n.get(Cs).donePromise.then(() => { const r = Dn(), o = t.querySelectorAll(`style[ng-transition="${e}"]`); for (let i = 0; i < o.length; i++)r.remove(o[i]) }) } }, deps: [gv, Ge, lt], multi: !0 }]; let Dx = (() => { class e { build() { return new XMLHttpRequest } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(); const $s = new P("EventManagerPlugins"); let Hs = (() => { class e { constructor(n, r) { this._zone = r, this._eventNameToPlugin = new Map, n.forEach(o => o.manager = this), this._plugins = n.slice().reverse() } addEventListener(n, r, o) { return this._findPluginFor(r).addEventListener(n, r, o) } addGlobalEventListener(n, r, o) { return this._findPluginFor(r).addGlobalEventListener(n, r, o) } getZone() { return this._zone } _findPluginFor(n) { const r = this._eventNameToPlugin.get(n); if (r) return r; const o = this._plugins; for (let i = 0; i < o.length; i++) { const s = o[i]; if (s.supports(n)) return this._eventNameToPlugin.set(n, s), s } throw new Error(`No event manager plugin found for event ${n}`) } } return e.\u0275fac = function (n) { return new (n || e)(b($s), b(_e)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(); class mv { constructor(t) { this._doc = t } addGlobalEventListener(t, n, r) { const o = Dn().getGlobalEventTarget(this._doc, t); if (!o) throw new Error(`Unsupported event target ${o} for event ${n}`); return this.addEventListener(o, n, r) } } let yv = (() => { class e { constructor() { this._stylesSet = new Set } addStyles(n) { const r = new Set; n.forEach(o => { this._stylesSet.has(o) || (this._stylesSet.add(o), r.add(o)) }), this.onStylesAdded(r) } onStylesAdded(n) { } getAllStyles() { return Array.from(this._stylesSet) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(), Wo = (() => { class e extends yv { constructor(n) { super(), this._doc = n, this._hostNodes = new Map, this._hostNodes.set(n.head, []) } _addStylesToHost(n, r, o) { n.forEach(i => { const s = this._doc.createElement("style"); s.textContent = i, o.push(r.appendChild(s)) }) } addHost(n) { const r = []; this._addStylesToHost(this._stylesSet, n, r), this._hostNodes.set(n, r) } removeHost(n) { const r = this._hostNodes.get(n); r && r.forEach(vv), this._hostNodes.delete(n) } onStylesAdded(n) { this._hostNodes.forEach((r, o) => { this._addStylesToHost(n, o, r) }) } ngOnDestroy() { this._hostNodes.forEach(n => n.forEach(vv)) } } return e.\u0275fac = function (n) { return new (n || e)(b(Ge)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(); function vv(e) { Dn().remove(e) } const Sc = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/MathML/" }, Mc = /%COMP%/g; function Bs(e, t, n) { for (let r = 0; r < t.length; r++) { let o = t[r]; Array.isArray(o) ? Bs(e, o, n) : (o = o.replace(Mc, e), n.push(o)) } return n } function Cv(e) { return t => { if ("__ngUnwrap__" === t) return e; !1 === e(t) && (t.preventDefault(), t.returnValue = !1) } } let Tc = (() => { class e { constructor(n, r, o) { this.eventManager = n, this.sharedStylesHost = r, this.appId = o, this.rendererByCompId = new Map, this.defaultRenderer = new Ac(n) } createRenderer(n, r) { if (!n || !r) return this.defaultRenderer; switch (r.encapsulation) { case Nt.Emulated: { let o = this.rendererByCompId.get(r.id); return o || (o = new Ix(this.eventManager, this.sharedStylesHost, r, this.appId), this.rendererByCompId.set(r.id, o)), o.applyToHost(n), o } case 1: case Nt.ShadowDom: return new Sx(this.eventManager, this.sharedStylesHost, n, r); default: if (!this.rendererByCompId.has(r.id)) { const o = Bs(r.id, r.styles, []); this.sharedStylesHost.addStyles(o), this.rendererByCompId.set(r.id, this.defaultRenderer) } return this.defaultRenderer } } begin() { } end() { } } return e.\u0275fac = function (n) { return new (n || e)(b(Hs), b(Wo), b($o)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(); class Ac { constructor(t) { this.eventManager = t, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(t, n) { return n ? document.createElementNS(Sc[n] || n, t) : document.createElement(t) } createComment(t) { return document.createComment(t) } createText(t) { return document.createTextNode(t) } appendChild(t, n) { (Ev(t) ? t.content : t).appendChild(n) } insertBefore(t, n, r) { t && (Ev(t) ? t.content : t).insertBefore(n, r) } removeChild(t, n) { t && t.removeChild(n) } selectRootElement(t, n) { let r = "string" == typeof t ? document.querySelector(t) : t; if (!r) throw new Error(`The selector "${t}" did not match any elements`); return n || (r.textContent = ""), r } parentNode(t) { return t.parentNode } nextSibling(t) { return t.nextSibling } setAttribute(t, n, r, o) { if (o) { n = o + ":" + n; const i = Sc[o]; i ? t.setAttributeNS(i, n, r) : t.setAttribute(n, r) } else t.setAttribute(n, r) } removeAttribute(t, n, r) { if (r) { const o = Sc[r]; o ? t.removeAttributeNS(o, n) : t.removeAttribute(`${r}:${n}`) } else t.removeAttribute(n) } addClass(t, n) { t.classList.add(n) } removeClass(t, n) { t.classList.remove(n) } setStyle(t, n, r, o) { o & (Ke.DashCase | Ke.Important) ? t.style.setProperty(n, r, o & Ke.Important ? "important" : "") : t.style[n] = r } removeStyle(t, n, r) { r & Ke.DashCase ? t.style.removeProperty(n) : t.style[n] = "" } setProperty(t, n, r) { t[n] = r } setValue(t, n) { t.nodeValue = n } listen(t, n, r) { return "string" == typeof t ? this.eventManager.addGlobalEventListener(t, n, Cv(r)) : this.eventManager.addEventListener(t, n, Cv(r)) } } function Ev(e) { return "TEMPLATE" === e.tagName && void 0 !== e.content } class Ix extends Ac { constructor(t, n, r, o) { super(t), this.component = r; const i = Bs(o + "-" + r.id, r.styles, []); n.addStyles(i), this.contentAttr = function _x(e) { return "_ngcontent-%COMP%".replace(Mc, e) }(o + "-" + r.id), this.hostAttr = function Ex(e) { return "_nghost-%COMP%".replace(Mc, e) }(o + "-" + r.id) } applyToHost(t) { super.setAttribute(t, this.hostAttr, "") } createElement(t, n) { const r = super.createElement(t, n); return super.setAttribute(r, this.contentAttr, ""), r } } class Sx extends Ac { constructor(t, n, r, o) { super(t), this.sharedStylesHost = n, this.hostEl = r, this.shadowRoot = r.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const i = Bs(o.id, o.styles, []); for (let s = 0; s < i.length; s++) { const a = document.createElement("style"); a.textContent = i[s], this.shadowRoot.appendChild(a) } } nodeOrShadowRoot(t) { return t === this.hostEl ? this.shadowRoot : t } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } appendChild(t, n) { return super.appendChild(this.nodeOrShadowRoot(t), n) } insertBefore(t, n, r) { return super.insertBefore(this.nodeOrShadowRoot(t), n, r) } removeChild(t, n) { return super.removeChild(this.nodeOrShadowRoot(t), n) } parentNode(t) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(t))) } } let Mx = (() => { class e extends mv { constructor(n) { super(n) } supports(n) { return !0 } addEventListener(n, r, o) { return n.addEventListener(r, o, !1), () => this.removeEventListener(n, r, o) } removeEventListener(n, r, o) { return n.removeEventListener(r, o) } } return e.\u0275fac = function (n) { return new (n || e)(b(Ge)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(); const bv = ["alt", "control", "meta", "shift"], Tx = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, Ax = { alt: e => e.altKey, control: e => e.ctrlKey, meta: e => e.metaKey, shift: e => e.shiftKey }; let xx = (() => { class e extends mv { constructor(n) { super(n) } supports(n) { return null != e.parseEventName(n) } addEventListener(n, r, o) { const i = e.parseEventName(r), s = e.eventCallback(i.fullKey, o, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => Dn().onAndCancel(n, i.domEventName, s)) } static parseEventName(n) { const r = n.toLowerCase().split("."), o = r.shift(); if (0 === r.length || "keydown" !== o && "keyup" !== o) return null; const i = e._normalizeKey(r.pop()); let s = "", a = r.indexOf("code"); if (a > -1 && (r.splice(a, 1), s = "code."), bv.forEach(l => { const c = r.indexOf(l); c > -1 && (r.splice(c, 1), s += l + ".") }), s += i, 0 != r.length || 0 === i.length) return null; const u = {}; return u.domEventName = o, u.fullKey = s, u } static matchEventFullKeyCode(n, r) { let o = Tx[n.key] || n.key, i = ""; return r.indexOf("code.") > -1 && (o = n.code, i = "code."), !(null == o || !o) && (o = o.toLowerCase(), " " === o ? o = "space" : "." === o && (o = "dot"), bv.forEach(s => { s !== o && (0, Ax[s])(n) && (i += s + ".") }), i += o, i === r) } static eventCallback(n, r, o) { return i => { e.matchEventFullKeyCode(i, n) && o.runGuarded(() => r(i)) } } static _normalizeKey(n) { return "esc" === n ? "escape" : n } } return e.\u0275fac = function (n) { return new (n || e)(b(Ge)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(); const Ox = _y(vT, "browser", [{ provide: Wl, useValue: "browser" }, { provide: fy, useValue: function Rx() { Ic.makeCurrent() }, multi: !0 }, { provide: Ge, useFactory: function Px() { return function I_(e) { ou = e }(document), document }, deps: [] }]), Mv = new P(""), Tv = [{ provide: _s, useClass: class vx { addToWindow(t) { X.getAngularTestability = (r, o = !0) => { const i = t.findTestabilityInTree(r, o); if (null == i) throw new Error("Could not find testability for element."); return i }, X.getAllAngularTestabilities = () => t.getAllTestabilities(), X.getAllAngularRootElements = () => t.getAllRootElements(), X.frameworkStabilizers || (X.frameworkStabilizers = []), X.frameworkStabilizers.push(r => { const o = X.getAllAngularTestabilities(); let i = o.length, s = !1; const a = function (u) { s = s || u, i--, 0 == i && r(s) }; o.forEach(function (u) { u.whenStable(a) }) }) } findTestabilityInTree(t, n, r) { return null == n ? null : t.getTestability(n) ?? (r ? Dn().isShadowRoot(n) ? this.findTestabilityInTree(t, n.host, !0) : this.findTestabilityInTree(t, n.parentElement, !0) : null) } }, deps: [] }, { provide: vy, useClass: Jl, deps: [_e, Yl, _s] }, { provide: Jl, useClass: Jl, deps: [_e, Yl, _s] }], Av = [{ provide: pu, useValue: "root" }, { provide: Dr, useFactory: function Nx() { return new Dr }, deps: [] }, { provide: $s, useClass: Mx, multi: !0, deps: [Ge, _e, Wl] }, { provide: $s, useClass: xx, multi: !0, deps: [Ge] }, { provide: Tc, useClass: Tc, deps: [Hs, Wo, $o] }, { provide: _h, useExisting: Tc }, { provide: yv, useExisting: Wo }, { provide: Wo, useClass: Wo, deps: [Ge] }, { provide: Hs, useClass: Hs, deps: [$s, _e] }, { provide: dv, useClass: Dx, deps: [] }, []]; let Fx = (() => { class e { constructor(n) { } static withServerTransition(n) { return { ngModule: e, providers: [{ provide: $o, useValue: n.appId }, { provide: gv, useExisting: $o }, yx] } } } return e.\u0275fac = function (n) { return new (n || e)(b(Mv, 12)) }, e.\u0275mod = Gt({ type: e }), e.\u0275inj = Rt({ providers: [...Av, ...Tv], imports: [UA, DT] }), e })(), xv = (() => { class e { constructor(n) { this._doc = n } getTitle() { return this._doc.title } setTitle(n) { this._doc.title = n || "" } } return e.\u0275fac = function (n) { return new (n || e)(b(Ge)) }, e.\u0275prov = N({ token: e, factory: function (n) { let r = null; return r = n ? new n : function Lx() { return new xv(b(Ge)) }(), r }, providedIn: "root" }), e })(); function M(...e) { return ve(e, Zr(e)) } function Cn(e, t) { return Y(t) ? Me(e, t, 1) : Me(e, 1) } function on(e, t) { return be((n, r) => { let o = 0; n.subscribe(Ie(r, i => e.call(t, i, o++) && r.next(i))) }) } typeof window < "u" && window; class Pv { } class Ov { } class sn { constructor(t) { this.normalizedNames = new Map, this.lazyUpdate = null, t ? this.lazyInit = "string" == typeof t ? () => { this.headers = new Map, t.split("\n").forEach(n => { const r = n.indexOf(":"); if (r > 0) { const o = n.slice(0, r), i = o.toLowerCase(), s = n.slice(r + 1).trim(); this.maybeSetNormalizedName(o, i), this.headers.has(i) ? this.headers.get(i).push(s) : this.headers.set(i, [s]) } }) } : () => { this.headers = new Map, Object.keys(t).forEach(n => { let r = t[n]; const o = n.toLowerCase(); "string" == typeof r && (r = [r]), r.length > 0 && (this.headers.set(o, r), this.maybeSetNormalizedName(n, o)) }) } : this.headers = new Map } has(t) { return this.init(), this.headers.has(t.toLowerCase()) } get(t) { this.init(); const n = this.headers.get(t.toLowerCase()); return n && n.length > 0 ? n[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(t) { return this.init(), this.headers.get(t.toLowerCase()) || null } append(t, n) { return this.clone({ name: t, value: n, op: "a" }) } set(t, n) { return this.clone({ name: t, value: n, op: "s" }) } delete(t, n) { return this.clone({ name: t, value: n, op: "d" }) } maybeSetNormalizedName(t, n) { this.normalizedNames.has(n) || this.normalizedNames.set(n, t) } init() { this.lazyInit && (this.lazyInit instanceof sn ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(t => this.applyUpdate(t)), this.lazyUpdate = null)) } copyFrom(t) { t.init(), Array.from(t.headers.keys()).forEach(n => { this.headers.set(n, t.headers.get(n)), this.normalizedNames.set(n, t.normalizedNames.get(n)) }) } clone(t) { const n = new sn; return n.lazyInit = this.lazyInit && this.lazyInit instanceof sn ? this.lazyInit : this, n.lazyUpdate = (this.lazyUpdate || []).concat([t]), n } applyUpdate(t) { const n = t.name.toLowerCase(); switch (t.op) { case "a": case "s": let r = t.value; if ("string" == typeof r && (r = [r]), 0 === r.length) return; this.maybeSetNormalizedName(t.name, n); const o = ("a" === t.op ? this.headers.get(n) : void 0) || []; o.push(...r), this.headers.set(n, o); break; case "d": const i = t.value; if (i) { let s = this.headers.get(n); if (!s) return; s = s.filter(a => -1 === i.indexOf(a)), 0 === s.length ? (this.headers.delete(n), this.normalizedNames.delete(n)) : this.headers.set(n, s) } else this.headers.delete(n), this.normalizedNames.delete(n) } } forEach(t) { this.init(), Array.from(this.normalizedNames.keys()).forEach(n => t(this.normalizedNames.get(n), this.headers.get(n))) } } class Gx { encodeKey(t) { return Fv(t) } encodeValue(t) { return Fv(t) } decodeKey(t) { return decodeURIComponent(t) } decodeValue(t) { return decodeURIComponent(t) } } const qx = /%(\d[a-f0-9])/gi, Kx = { 40: "@", "3A": ":", 24: "$", "2C": ",", "3B": ";", "3D": "=", "3F": "?", "2F": "/" }; function Fv(e) { return encodeURIComponent(e).replace(qx, (t, n) => Kx[n] ?? t) } function Us(e) { return `${e}` } class _n { constructor(t = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = t.encoder || new Gx, t.fromString) { if (t.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function Wx(e, t) { const n = new Map; return e.length > 0 && e.replace(/^\?/, "").split("&").forEach(o => { const i = o.indexOf("="), [s, a] = -1 == i ? [t.decodeKey(o), ""] : [t.decodeKey(o.slice(0, i)), t.decodeValue(o.slice(i + 1))], u = n.get(s) || []; u.push(a), n.set(s, u) }), n }(t.fromString, this.encoder) } else t.fromObject ? (this.map = new Map, Object.keys(t.fromObject).forEach(n => { const r = t.fromObject[n], o = Array.isArray(r) ? r.map(Us) : [Us(r)]; this.map.set(n, o) })) : this.map = null } has(t) { return this.init(), this.map.has(t) } get(t) { this.init(); const n = this.map.get(t); return n ? n[0] : null } getAll(t) { return this.init(), this.map.get(t) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(t, n) { return this.clone({ param: t, value: n, op: "a" }) } appendAll(t) { const n = []; return Object.keys(t).forEach(r => { const o = t[r]; Array.isArray(o) ? o.forEach(i => { n.push({ param: r, value: i, op: "a" }) }) : n.push({ param: r, value: o, op: "a" }) }), this.clone(n) } set(t, n) { return this.clone({ param: t, value: n, op: "s" }) } delete(t, n) { return this.clone({ param: t, value: n, op: "d" }) } toString() { return this.init(), this.keys().map(t => { const n = this.encoder.encodeKey(t); return this.map.get(t).map(r => n + "=" + this.encoder.encodeValue(r)).join("&") }).filter(t => "" !== t).join("&") } clone(t) { const n = new _n({ encoder: this.encoder }); return n.cloneFrom = this.cloneFrom || this, n.updates = (this.updates || []).concat(t), n } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(t => this.map.set(t, this.cloneFrom.map.get(t))), this.updates.forEach(t => { switch (t.op) { case "a": case "s": const n = ("a" === t.op ? this.map.get(t.param) : void 0) || []; n.push(Us(t.value)), this.map.set(t.param, n); break; case "d": if (void 0 === t.value) { this.map.delete(t.param); break } { let r = this.map.get(t.param) || []; const o = r.indexOf(Us(t.value)); -1 !== o && r.splice(o, 1), r.length > 0 ? this.map.set(t.param, r) : this.map.delete(t.param) } } }), this.cloneFrom = this.updates = null) } } class Qx { constructor() { this.map = new Map } set(t, n) { return this.map.set(t, n), this } get(t) { return this.map.has(t) || this.map.set(t, t.defaultValue()), this.map.get(t) } delete(t) { return this.map.delete(t), this } has(t) { return this.map.has(t) } keys() { return this.map.keys() } } function kv(e) { return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer } function Lv(e) { return typeof Blob < "u" && e instanceof Blob } function jv(e) { return typeof FormData < "u" && e instanceof FormData } class qo { constructor(t, n, r, o) { let i; if (this.url = n, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = t.toUpperCase(), function Zx(e) { switch (e) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || o ? (this.body = void 0 !== r ? r : null, i = o) : i = r, i && (this.reportProgress = !!i.reportProgress, this.withCredentials = !!i.withCredentials, i.responseType && (this.responseType = i.responseType), i.headers && (this.headers = i.headers), i.context && (this.context = i.context), i.params && (this.params = i.params)), this.headers || (this.headers = new sn), this.context || (this.context = new Qx), this.params) { const s = this.params.toString(); if (0 === s.length) this.urlWithParams = n; else { const a = n.indexOf("?"); this.urlWithParams = n + (-1 === a ? "?" : a < n.length - 1 ? "&" : "") + s } } else this.params = new _n, this.urlWithParams = n } serializeBody() { return null === this.body ? null : kv(this.body) || Lv(this.body) || jv(this.body) || function Jx(e) { return typeof URLSearchParams < "u" && e instanceof URLSearchParams }(this.body) || "string" == typeof this.body ? this.body : this.body instanceof _n ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || jv(this.body) ? null : Lv(this.body) ? this.body.type || null : kv(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof _n ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null } clone(t = {}) { const n = t.method || this.method, r = t.url || this.url, o = t.responseType || this.responseType, i = void 0 !== t.body ? t.body : this.body, s = void 0 !== t.withCredentials ? t.withCredentials : this.withCredentials, a = void 0 !== t.reportProgress ? t.reportProgress : this.reportProgress; let u = t.headers || this.headers, l = t.params || this.params; const c = t.context ?? this.context; return void 0 !== t.setHeaders && (u = Object.keys(t.setHeaders).reduce((d, f) => d.set(f, t.setHeaders[f]), u)), t.setParams && (l = Object.keys(t.setParams).reduce((d, f) => d.set(f, t.setParams[f]), l)), new qo(n, r, i, { params: l, headers: u, context: c, reportProgress: a, responseType: o, withCredentials: s }) } } var ye = (() => ((ye = ye || {})[ye.Sent = 0] = "Sent", ye[ye.UploadProgress = 1] = "UploadProgress", ye[ye.ResponseHeader = 2] = "ResponseHeader", ye[ye.DownloadProgress = 3] = "DownloadProgress", ye[ye.Response = 4] = "Response", ye[ye.User = 5] = "User", ye))(); class Nc { constructor(t, n = 200, r = "OK") { this.headers = t.headers || new sn, this.status = void 0 !== t.status ? t.status : n, this.statusText = t.statusText || r, this.url = t.url || null, this.ok = this.status >= 200 && this.status < 300 } } class Pc extends Nc { constructor(t = {}) { super(t), this.type = ye.ResponseHeader } clone(t = {}) { return new Pc({ headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class zs extends Nc { constructor(t = {}) { super(t), this.type = ye.Response, this.body = void 0 !== t.body ? t.body : null } clone(t = {}) { return new zs({ body: void 0 !== t.body ? t.body : this.body, headers: t.headers || this.headers, status: void 0 !== t.status ? t.status : this.status, statusText: t.statusText || this.statusText, url: t.url || this.url || void 0 }) } } class Vv extends Nc { constructor(t) { super(t, 0, "Unknown Error"), this.name = "HttpErrorResponse", this.ok = !1, this.message = this.status >= 200 && this.status < 300 ? `Http failure during parsing for ${t.url || "(unknown url)"}` : `Http failure response for ${t.url || "(unknown url)"}: ${t.status} ${t.statusText}`, this.error = t.error || null } } function Oc(e, t) { return { body: t, headers: e.headers, context: e.context, observe: e.observe, params: e.params, reportProgress: e.reportProgress, responseType: e.responseType, withCredentials: e.withCredentials } } let $v = (() => { class e { constructor(n) { this.handler = n } request(n, r, o = {}) { let i; if (n instanceof qo) i = n; else { let u, l; u = o.headers instanceof sn ? o.headers : new sn(o.headers), o.params && (l = o.params instanceof _n ? o.params : new _n({ fromObject: o.params })), i = new qo(n, r, void 0 !== o.body ? o.body : null, { headers: u, context: o.context, params: l, reportProgress: o.reportProgress, responseType: o.responseType || "json", withCredentials: o.withCredentials }) } const s = M(i).pipe(Cn(u => this.handler.handle(u))); if (n instanceof qo || "events" === o.observe) return s; const a = s.pipe(on(u => u instanceof zs)); switch (o.observe || "body") { case "body": switch (i.responseType) { case "arraybuffer": return a.pipe(B(u => { if (null !== u.body && !(u.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return u.body })); case "blob": return a.pipe(B(u => { if (null !== u.body && !(u.body instanceof Blob)) throw new Error("Response is not a Blob."); return u.body })); case "text": return a.pipe(B(u => { if (null !== u.body && "string" != typeof u.body) throw new Error("Response is not a string."); return u.body })); default: return a.pipe(B(u => u.body)) }case "response": return a; default: throw new Error(`Unreachable: unhandled observe type ${o.observe}}`) } } delete(n, r = {}) { return this.request("DELETE", n, r) } get(n, r = {}) { return this.request("GET", n, r) } head(n, r = {}) { return this.request("HEAD", n, r) } jsonp(n, r) { return this.request("JSONP", n, { params: (new _n).append(r, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(n, r = {}) { return this.request("OPTIONS", n, r) } patch(n, r, o = {}) { return this.request("PATCH", n, Oc(o, r)) } post(n, r, o = {}) { return this.request("POST", n, Oc(o, r)) } put(n, r, o = {}) { return this.request("PUT", n, Oc(o, r)) } } return e.\u0275fac = function (n) { return new (n || e)(b(Pv)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(); class Hv { constructor(t, n) { this.next = t, this.interceptor = n } handle(t) { return this.interceptor.intercept(t, this.next) } } const Bv = new P("HTTP_INTERCEPTORS"); let Yx = (() => { class e { intercept(n, r) { return r.handle(n) } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(); const Xx = /^\)\]\}',?\n/; let Uv = (() => { class e { constructor(n) { this.xhrFactory = n } handle(n) { if ("JSONP" === n.method) throw new Error("Attempted to construct Jsonp request without HttpClientJsonpModule installed."); return new de(r => { const o = this.xhrFactory.build(); if (o.open(n.method, n.urlWithParams), n.withCredentials && (o.withCredentials = !0), n.headers.forEach((h, p) => o.setRequestHeader(h, p.join(","))), n.headers.has("Accept") || o.setRequestHeader("Accept", "application/json, text/plain, */*"), !n.headers.has("Content-Type")) { const h = n.detectContentTypeHeader(); null !== h && o.setRequestHeader("Content-Type", h) } if (n.responseType) { const h = n.responseType.toLowerCase(); o.responseType = "json" !== h ? h : "text" } const i = n.serializeBody(); let s = null; const a = () => { if (null !== s) return s; const h = o.statusText || "OK", p = new sn(o.getAllResponseHeaders()), g = function eR(e) { return "responseURL" in e && e.responseURL ? e.responseURL : /^X-Request-URL:/m.test(e.getAllResponseHeaders()) ? e.getResponseHeader("X-Request-URL") : null }(o) || n.url; return s = new Pc({ headers: p, status: o.status, statusText: h, url: g }), s }, u = () => { let { headers: h, status: p, statusText: g, url: y } = a(), D = null; 204 !== p && (D = typeof o.response > "u" ? o.responseText : o.response), 0 === p && (p = D ? 200 : 0); let w = p >= 200 && p < 300; if ("json" === n.responseType && "string" == typeof D) { const m = D; D = D.replace(Xx, ""); try { D = "" !== D ? JSON.parse(D) : null } catch (S) { D = m, w && (w = !1, D = { error: S, text: D }) } } w ? (r.next(new zs({ body: D, headers: h, status: p, statusText: g, url: y || void 0 })), r.complete()) : r.error(new Vv({ error: D, headers: h, status: p, statusText: g, url: y || void 0 })) }, l = h => { const { url: p } = a(), g = new Vv({ error: h, status: o.status || 0, statusText: o.statusText || "Unknown Error", url: p || void 0 }); r.error(g) }; let c = !1; const d = h => { c || (r.next(a()), c = !0); let p = { type: ye.DownloadProgress, loaded: h.loaded }; h.lengthComputable && (p.total = h.total), "text" === n.responseType && !!o.responseText && (p.partialText = o.responseText), r.next(p) }, f = h => { let p = { type: ye.UploadProgress, loaded: h.loaded }; h.lengthComputable && (p.total = h.total), r.next(p) }; return o.addEventListener("load", u), o.addEventListener("error", l), o.addEventListener("timeout", l), o.addEventListener("abort", l), n.reportProgress && (o.addEventListener("progress", d), null !== i && o.upload && o.upload.addEventListener("progress", f)), o.send(i), r.next({ type: ye.Sent }), () => { o.removeEventListener("error", l), o.removeEventListener("abort", l), o.removeEventListener("load", u), o.removeEventListener("timeout", l), n.reportProgress && (o.removeEventListener("progress", d), null !== i && o.upload && o.upload.removeEventListener("progress", f)), o.readyState !== o.DONE && o.abort() } }) } } return e.\u0275fac = function (n) { return new (n || e)(b(dv)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(); const Fc = new P("XSRF_COOKIE_NAME"), kc = new P("XSRF_HEADER_NAME"); class zv { } let tR = (() => { class e { constructor(n, r, o) { this.doc = n, this.platform = r, this.cookieName = o, this.lastCookieString = "", this.lastToken = null, this.parseCount = 0 } getToken() { if ("server" === this.platform) return null; const n = this.doc.cookie || ""; return n !== this.lastCookieString && (this.parseCount++, this.lastToken = tv(n, this.cookieName), this.lastCookieString = n), this.lastToken } } return e.\u0275fac = function (n) { return new (n || e)(b(Ge), b(Wl), b(Fc)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(), Lc = (() => { class e { constructor(n, r) { this.tokenService = n, this.headerName = r } intercept(n, r) { const o = n.url.toLowerCase(); if ("GET" === n.method || "HEAD" === n.method || o.startsWith("http://") || o.startsWith("https://")) return r.handle(n); const i = this.tokenService.getToken(); return null !== i && !n.headers.has(this.headerName) && (n = n.clone({ headers: n.headers.set(this.headerName, i) })), r.handle(n) } } return e.\u0275fac = function (n) { return new (n || e)(b(zv), b(kc)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(), nR = (() => { class e { constructor(n, r) { this.backend = n, this.injector = r, this.chain = null } handle(n) { if (null === this.chain) { const r = this.injector.get(Bv, []); this.chain = r.reduceRight((o, i) => new Hv(o, i), this.backend) } return this.chain.handle(n) } } return e.\u0275fac = function (n) { return new (n || e)(b(Ov), b(lt)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(), rR = (() => { class e { static disable() { return { ngModule: e, providers: [{ provide: Lc, useClass: Yx }] } } static withOptions(n = {}) { return { ngModule: e, providers: [n.cookieName ? { provide: Fc, useValue: n.cookieName } : [], n.headerName ? { provide: kc, useValue: n.headerName } : []] } } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = Gt({ type: e }), e.\u0275inj = Rt({ providers: [Lc, { provide: Bv, useExisting: Lc, multi: !0 }, { provide: zv, useClass: tR }, { provide: Fc, useValue: "XSRF-TOKEN" }, { provide: kc, useValue: "X-XSRF-TOKEN" }] }), e })(), oR = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = Gt({ type: e }), e.\u0275inj = Rt({ providers: [$v, { provide: Pv, useClass: nR }, Uv, { provide: Ov, useExisting: Uv }], imports: [rR.withOptions({ cookieName: "XSRF-TOKEN", headerName: "X-XSRF-TOKEN" })] }), e })(); class Tt extends At { constructor(t) { super(), this._value = t } get value() { return this.getValue() } _subscribe(t) { const n = super._subscribe(t); return !n.closed && t.next(this._value), n } getValue() { const { hasError: t, thrownError: n, _value: r } = this; if (t) throw n; return this._throwIfClosed(), r } next(t) { super.next(this._value = t) } } const Gs = qr(e => function () { e(this), this.name = "EmptyError", this.message = "no elements in sequence" }), { isArray: iR } = Array, { getPrototypeOf: sR, prototype: aR, keys: uR } = Object; const { isArray: dR } = Array; function Gv(...e) { const t = Zr(e), n = function Nw(e) { return Y(Da(e)) ? e.pop() : void 0 }(e), { args: r, keys: o } = function lR(e) { if (1 === e.length) { const t = e[0]; if (iR(t)) return { args: t, keys: null }; if (function cR(e) { return e && "object" == typeof e && sR(e) === aR }(t)) { const n = uR(t); return { args: n.map(r => t[r]), keys: n } } } return { args: e, keys: null } }(e); if (0 === r.length) return ve([], t); const i = new de(function gR(e, t, n = Tn) { return r => { Wv(t, () => { const { length: o } = e, i = new Array(o); let s = o, a = o; for (let u = 0; u < o; u++)Wv(t, () => { const l = ve(e[u], t); let c = !1; l.subscribe(Ie(r, d => { i[u] = d, c || (c = !0, a--), a || r.next(n(i.slice())) }, () => { --s || r.complete() })) }, r) }, r) } }(r, t, o ? s => function pR(e, t) { return e.reduce((n, r, o) => (n[r] = t[o], n), {}) }(o, s) : Tn)); return n ? i.pipe(function hR(e) { return B(t => function fR(e, t) { return dR(t) ? e(...t) : e(t) }(e, t)) }(n)) : i } function Wv(e, t, n) { e ? Ht(n, e, t) : t() } function jc(...e) { return function mR() { return Yn(1) }()(ve(e, Zr(e))) } function qv(e) { return new de(t => { xt(e()).subscribe(t) }) } function Ko(e, t) { const n = Y(e) ? e : () => e, r = o => o.error(n()); return new de(t ? o => t.schedule(r, 0, o) : r) } function Vc() { return be((e, t) => { let n = null; e._refCount++; const r = Ie(t, void 0, void 0, void 0, () => { if (!e || e._refCount <= 0 || 0 < --e._refCount) return void (n = null); const o = e._connection, i = n; n = null, o && (!i || o === i) && o.unsubscribe(), t.unsubscribe() }); e.subscribe(r), r.closed || (n = e.connect()) }) } class Kv extends de { constructor(t, n) { super(), this.source = t, this.subjectFactory = n, this._subject = null, this._refCount = 0, this._connection = null, Od(t) && (this.lift = t.lift) } _subscribe(t) { return this.getSubject().subscribe(t) } getSubject() { const t = this._subject; return (!t || t.isStopped) && (this._subject = this.subjectFactory()), this._subject } _teardown() { this._refCount = 0; const { _connection: t } = this; this._subject = this._connection = null, t?.unsubscribe() } connect() { let t = this._connection; if (!t) { t = this._connection = new ot; const n = this.getSubject(); t.add(this.source.subscribe(Ie(n, void 0, () => { this._teardown(), n.complete() }, r => { this._teardown(), n.error(r) }, () => this._teardown()))), t.closed && (this._connection = null, t = ot.EMPTY) } return t } refCount() { return Vc()(this) } } function Vt(e, t) { return be((n, r) => { let o = null, i = 0, s = !1; const a = () => s && !o && r.complete(); n.subscribe(Ie(r, u => { o?.unsubscribe(); let l = 0; const c = i++; xt(e(u, c)).subscribe(o = Ie(r, d => r.next(t ? t(u, d, c, l++) : d), () => { o = null, a() })) }, () => { s = !0, a() })) }) } function Qo(e) { return e <= 0 ? () => Bt : be((t, n) => { let r = 0; t.subscribe(Ie(n, o => { ++r <= e && (n.next(o), e <= r && n.complete()) })) }) } function Ws(e) { return be((t, n) => { let r = !1; t.subscribe(Ie(n, o => { r = !0, n.next(o) }, () => { r || n.next(e), n.complete() })) }) } function Qv(e = vR) { return be((t, n) => { let r = !1; t.subscribe(Ie(n, o => { r = !0, n.next(o) }, () => r ? n.complete() : n.error(e()))) }) } function vR() { return new Gs } function En(e, t) { const n = arguments.length >= 2; return r => r.pipe(e ? on((o, i) => e(o, i, r)) : Tn, Qo(1), n ? Ws(t) : Qv(() => new Gs)) } function ke(e, t, n) { const r = Y(e) || t || n ? { next: e, error: t, complete: n } : e; return r ? be((o, i) => { var s; null === (s = r.subscribe) || void 0 === s || s.call(r); let a = !0; o.subscribe(Ie(i, u => { var l; null === (l = r.next) || void 0 === l || l.call(r, u), i.next(u) }, () => { var u; a = !1, null === (u = r.complete) || void 0 === u || u.call(r), i.complete() }, u => { var l; a = !1, null === (l = r.error) || void 0 === l || l.call(r, u), i.error(u) }, () => { var u, l; a && (null === (u = r.unsubscribe) || void 0 === u || u.call(r)), null === (l = r.finalize) || void 0 === l || l.call(r) })) }) : Tn } function bn(e) { return be((t, n) => { let i, r = null, o = !1; r = t.subscribe(Ie(n, void 0, void 0, s => { i = xt(e(s, bn(e)(t))), r ? (r.unsubscribe(), r = null, i.subscribe(n)) : o = !0 })), o && (r.unsubscribe(), r = null, i.subscribe(n)) }) } function DR(e, t, n, r, o) { return (i, s) => { let a = n, u = t, l = 0; i.subscribe(Ie(s, c => { const d = l++; u = a ? e(u, c, d) : (a = !0, c), r && s.next(u) }, o && (() => { a && s.next(u), s.complete() }))) } } function Zv(e, t) { return be(DR(e, t, arguments.length >= 2, !0)) } function $c(e) { return e <= 0 ? () => Bt : be((t, n) => { let r = []; t.subscribe(Ie(n, o => { r.push(o), e < r.length && r.shift() }, () => { for (const o of r) n.next(o); n.complete() }, void 0, () => { r = null })) }) } function Jv(e, t) { const n = arguments.length >= 2; return r => r.pipe(e ? on((o, i) => e(o, i, r)) : Tn, $c(1), n ? Ws(t) : Qv(() => new Gs)) } function Hc(e) { return be((t, n) => { try { t.subscribe(n) } finally { n.add(e) } }) } const $ = "primary", Zo = Symbol("RouteTitle"); class _R { constructor(t) { this.params = t || {} } has(t) { return Object.prototype.hasOwnProperty.call(this.params, t) } get(t) { if (this.has(t)) { const n = this.params[t]; return Array.isArray(n) ? n[0] : n } return null } getAll(t) { if (this.has(t)) { const n = this.params[t]; return Array.isArray(n) ? n : [n] } return [] } get keys() { return Object.keys(this.params) } } function $r(e) { return new _R(e) } function ER(e, t, n) { const r = n.path.split("/"); if (r.length > e.length || "full" === n.pathMatch && (t.hasChildren() || r.length < e.length)) return null; const o = {}; for (let i = 0; i < r.length; i++) { const s = r[i], a = e[i]; if (s.startsWith(":")) o[s.substring(1)] = a; else if (s !== a.path) return null } return { consumed: e.slice(0, r.length), posParams: o } } function $t(e, t) { const n = e ? Object.keys(e) : void 0, r = t ? Object.keys(t) : void 0; if (!n || !r || n.length != r.length) return !1; let o; for (let i = 0; i < n.length; i++)if (o = n[i], !Yv(e[o], t[o])) return !1; return !0 } function Yv(e, t) { if (Array.isArray(e) && Array.isArray(t)) { if (e.length !== t.length) return !1; const n = [...e].sort(), r = [...t].sort(); return n.every((o, i) => r[i] === o) } return e === t } function Xv(e) { return Array.prototype.concat.apply([], e) } function eD(e) { return e.length > 0 ? e[e.length - 1] : null } function Te(e, t) { for (const n in e) e.hasOwnProperty(n) && t(e[n], n) } function In(e) { return og(e) ? e : us(e) ? ve(Promise.resolve(e)) : M(e) } const SR = { exact: function rD(e, t, n) { if (!qn(e.segments, t.segments) || !qs(e.segments, t.segments, n) || e.numberOfChildren !== t.numberOfChildren) return !1; for (const r in t.children) if (!e.children[r] || !rD(e.children[r], t.children[r], n)) return !1; return !0 }, subset: oD }, tD = { exact: function MR(e, t) { return $t(e, t) }, subset: function TR(e, t) { return Object.keys(t).length <= Object.keys(e).length && Object.keys(t).every(n => Yv(e[n], t[n])) }, ignored: () => !0 }; function nD(e, t, n) { return SR[n.paths](e.root, t.root, n.matrixParams) && tD[n.queryParams](e.queryParams, t.queryParams) && !("exact" === n.fragment && e.fragment !== t.fragment) } function oD(e, t, n) { return iD(e, t, t.segments, n) } function iD(e, t, n, r) { if (e.segments.length > n.length) { const o = e.segments.slice(0, n.length); return !(!qn(o, n) || t.hasChildren() || !qs(o, n, r)) } if (e.segments.length === n.length) { if (!qn(e.segments, n) || !qs(e.segments, n, r)) return !1; for (const o in t.children) if (!e.children[o] || !oD(e.children[o], t.children[o], r)) return !1; return !0 } { const o = n.slice(0, e.segments.length), i = n.slice(e.segments.length); return !!(qn(e.segments, o) && qs(e.segments, o, r) && e.children[$]) && iD(e.children[$], t, i, r) } } function qs(e, t, n) { return t.every((r, o) => tD[n](e[o].parameters, r.parameters)) } class Wn { constructor(t, n, r) { this.root = t, this.queryParams = n, this.fragment = r } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = $r(this.queryParams)), this._queryParamMap } toString() { return RR.serialize(this) } } class H { constructor(t, n) { this.segments = t, this.children = n, this.parent = null, Te(n, (r, o) => r.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return Ks(this) } } class Jo { constructor(t, n) { this.path = t, this.parameters = n } get parameterMap() { return this._parameterMap || (this._parameterMap = $r(this.parameters)), this._parameterMap } toString() { return lD(this) } } function qn(e, t) { return e.length === t.length && e.every((n, r) => n.path === t[r].path) } let sD = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: function () { return new Uc }, providedIn: "root" }), e })(); class Uc { parse(t) { const n = new $R(t); return new Wn(n.parseRootSegment(), n.parseQueryParams(), n.parseFragment()) } serialize(t) { const n = `/${Yo(t.root, !0)}`, r = function OR(e) { const t = Object.keys(e).map(n => { const r = e[n]; return Array.isArray(r) ? r.map(o => `${Qs(n)}=${Qs(o)}`).join("&") : `${Qs(n)}=${Qs(r)}` }).filter(n => !!n); return t.length ? `?${t.join("&")}` : "" }(t.queryParams); return `${n}${r}${"string" == typeof t.fragment ? `#${function NR(e) { return encodeURI(e) }(t.fragment)}` : ""}` } } const RR = new Uc; function Ks(e) { return e.segments.map(t => lD(t)).join("/") } function Yo(e, t) { if (!e.hasChildren()) return Ks(e); if (t) { const n = e.children[$] ? Yo(e.children[$], !1) : "", r = []; return Te(e.children, (o, i) => { i !== $ && r.push(`${i}:${Yo(o, !1)}`) }), r.length > 0 ? `${n}(${r.join("//")})` : n } { const n = function xR(e, t) { let n = []; return Te(e.children, (r, o) => { o === $ && (n = n.concat(t(r, o))) }), Te(e.children, (r, o) => { o !== $ && (n = n.concat(t(r, o))) }), n }(e, (r, o) => o === $ ? [Yo(e.children[$], !1)] : [`${o}:${Yo(r, !1)}`]); return 1 === Object.keys(e.children).length && null != e.children[$] ? `${Ks(e)}/${n[0]}` : `${Ks(e)}/(${n.join("//")})` } } function aD(e) { return encodeURIComponent(e).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function Qs(e) { return aD(e).replace(/%3B/gi, ";") } function zc(e) { return aD(e).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function Zs(e) { return decodeURIComponent(e) } function uD(e) { return Zs(e.replace(/\+/g, "%20")) } function lD(e) { return `${zc(e.path)}${function PR(e) { return Object.keys(e).map(t => `;${zc(t)}=${zc(e[t])}`).join("") }(e.parameters)}` } const FR = /^[^\/()?;=#]+/; function Js(e) { const t = e.match(FR); return t ? t[0] : "" } const kR = /^[^=?&#]+/, jR = /^[^&#]+/; class $R { constructor(t) { this.url = t, this.remaining = t } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new H([], {}) : new H([], this.parseChildren()) } parseQueryParams() { const t = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(t) } while (this.consumeOptional("&")); return t } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const t = []; for (this.peekStartsWith("(") || t.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), t.push(this.parseSegment()); let n = {}; this.peekStartsWith("/(") && (this.capture("/"), n = this.parseParens(!0)); let r = {}; return this.peekStartsWith("(") && (r = this.parseParens(!1)), (t.length > 0 || Object.keys(n).length > 0) && (r[$] = new H(t, n)), r } parseSegment() { const t = Js(this.remaining); if ("" === t && this.peekStartsWith(";")) throw new E(4009, !1); return this.capture(t), new Jo(Zs(t), this.parseMatrixParams()) } parseMatrixParams() { const t = {}; for (; this.consumeOptional(";");)this.parseParam(t); return t } parseParam(t) { const n = Js(this.remaining); if (!n) return; this.capture(n); let r = ""; if (this.consumeOptional("=")) { const o = Js(this.remaining); o && (r = o, this.capture(r)) } t[Zs(n)] = Zs(r) } parseQueryParam(t) { const n = function LR(e) { const t = e.match(kR); return t ? t[0] : "" }(this.remaining); if (!n) return; this.capture(n); let r = ""; if (this.consumeOptional("=")) { const s = function VR(e) { const t = e.match(jR); return t ? t[0] : "" }(this.remaining); s && (r = s, this.capture(r)) } const o = uD(n), i = uD(r); if (t.hasOwnProperty(o)) { let s = t[o]; Array.isArray(s) || (s = [s], t[o] = s), s.push(i) } else t[o] = i } parseParens(t) { const n = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const r = Js(this.remaining), o = this.remaining[r.length]; if ("/" !== o && ")" !== o && ";" !== o) throw new E(4010, !1); let i; r.indexOf(":") > -1 ? (i = r.slice(0, r.indexOf(":")), this.capture(i), this.capture(":")) : t && (i = $); const s = this.parseChildren(); n[i] = 1 === Object.keys(s).length ? s[$] : new H([], s), this.consumeOptional("//") } return n } peekStartsWith(t) { return this.remaining.startsWith(t) } consumeOptional(t) { return !!this.peekStartsWith(t) && (this.remaining = this.remaining.substring(t.length), !0) } capture(t) { if (!this.consumeOptional(t)) throw new E(4011, !1) } } function Gc(e) { return e.segments.length > 0 ? new H([], { [$]: e }) : e } function Ys(e) { const t = {}; for (const r of Object.keys(e.children)) { const i = Ys(e.children[r]); (i.segments.length > 0 || i.hasChildren()) && (t[r] = i) } return function HR(e) { if (1 === e.numberOfChildren && e.children[$]) { const t = e.children[$]; return new H(e.segments.concat(t.segments), t.children) } return e }(new H(e.segments, t)) } function Kn(e) { return e instanceof Wn } function zR(e, t, n, r, o) { if (0 === n.length) return Hr(t.root, t.root, t.root, r, o); const i = function fD(e) { if ("string" == typeof e[0] && 1 === e.length && "/" === e[0]) return new dD(!0, 0, e); let t = 0, n = !1; const r = e.reduce((o, i, s) => { if ("object" == typeof i && null != i) { if (i.outlets) { const a = {}; return Te(i.outlets, (u, l) => { a[l] = "string" == typeof u ? u.split("/") : u }), [...o, { outlets: a }] } if (i.segmentPath) return [...o, i.segmentPath] } return "string" != typeof i ? [...o, i] : 0 === s ? (i.split("/").forEach((a, u) => { 0 == u && "." === a || (0 == u && "" === a ? n = !0 : ".." === a ? t++ : "" != a && o.push(a)) }), o) : [...o, i] }, []); return new dD(n, t, r) }(n); return i.toRoot() ? Hr(t.root, t.root, new H([], {}), r, o) : function s(u) { const l = function WR(e, t, n, r) { if (e.isAbsolute) return new Br(t.root, !0, 0); if (-1 === r) return new Br(n, n === t.root, 0); return function hD(e, t, n) { let r = e, o = t, i = n; for (; i > o;) { if (i -= o, r = r.parent, !r) throw new E(4005, !1); o = r.segments.length } return new Br(r, !1, o - i) }(n, r + (Xo(e.commands[0]) ? 0 : 1), e.numberOfDoubleDots) }(i, t, e.snapshot?._urlSegment, u), c = l.processChildren ? ti(l.segmentGroup, l.index, i.commands) : qc(l.segmentGroup, l.index, i.commands); return Hr(t.root, l.segmentGroup, c, r, o) }(e.snapshot?._lastPathIndex) } function Xo(e) { return "object" == typeof e && null != e && !e.outlets && !e.segmentPath } function ei(e) { return "object" == typeof e && null != e && e.outlets } function Hr(e, t, n, r, o) { let s, i = {}; r && Te(r, (u, l) => { i[l] = Array.isArray(u) ? u.map(c => `${c}`) : `${u}` }), s = e === t ? n : cD(e, t, n); const a = Gc(Ys(s)); return new Wn(a, i, o) } function cD(e, t, n) { const r = {}; return Te(e.children, (o, i) => { r[i] = o === t ? n : cD(o, t, n) }), new H(e.segments, r) } class dD { constructor(t, n, r) { if (this.isAbsolute = t, this.numberOfDoubleDots = n, this.commands = r, t && r.length > 0 && Xo(r[0])) throw new E(4003, !1); const o = r.find(ei); if (o && o !== eD(r)) throw new E(4004, !1) } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class Br { constructor(t, n, r) { this.segmentGroup = t, this.processChildren = n, this.index = r } } function qc(e, t, n) { if (e || (e = new H([], {})), 0 === e.segments.length && e.hasChildren()) return ti(e, t, n); const r = function KR(e, t, n) { let r = 0, o = t; const i = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; o < e.segments.length;) { if (r >= n.length) return i; const s = e.segments[o], a = n[r]; if (ei(a)) break; const u = `${a}`, l = r < n.length - 1 ? n[r + 1] : null; if (o > 0 && void 0 === u) break; if (u && l && "object" == typeof l && void 0 === l.outlets) { if (!gD(u, l, s)) return i; r += 2 } else { if (!gD(u, {}, s)) return i; r++ } o++ } return { match: !0, pathIndex: o, commandIndex: r } }(e, t, n), o = n.slice(r.commandIndex); if (r.match && r.pathIndex < e.segments.length) { const i = new H(e.segments.slice(0, r.pathIndex), {}); return i.children[$] = new H(e.segments.slice(r.pathIndex), e.children), ti(i, 0, o) } return r.match && 0 === o.length ? new H(e.segments, {}) : r.match && !e.hasChildren() ? Kc(e, t, n) : r.match ? ti(e, 0, o) : Kc(e, t, n) } function ti(e, t, n) { if (0 === n.length) return new H(e.segments, {}); { const r = function qR(e) { return ei(e[0]) ? e[0].outlets : { [$]: e } }(n), o = {}; return Te(r, (i, s) => { "string" == typeof i && (i = [i]), null !== i && (o[s] = qc(e.children[s], t, i)) }), Te(e.children, (i, s) => { void 0 === r[s] && (o[s] = i) }), new H(e.segments, o) } } function Kc(e, t, n) { const r = e.segments.slice(0, t); let o = 0; for (; o < n.length;) { const i = n[o]; if (ei(i)) { const u = QR(i.outlets); return new H(r, u) } if (0 === o && Xo(n[0])) { r.push(new Jo(e.segments[t].path, pD(n[0]))), o++; continue } const s = ei(i) ? i.outlets[$] : `${i}`, a = o < n.length - 1 ? n[o + 1] : null; s && a && Xo(a) ? (r.push(new Jo(s, pD(a))), o += 2) : (r.push(new Jo(s, {})), o++) } return new H(r, {}) } function QR(e) { const t = {}; return Te(e, (n, r) => { "string" == typeof n && (n = [n]), null !== n && (t[r] = Kc(new H([], {}), 0, n)) }), t } function pD(e) { const t = {}; return Te(e, (n, r) => t[r] = `${n}`), t } function gD(e, t, n) { return e == n.path && $t(t, n.parameters) } class an { constructor(t, n) { this.id = t, this.url = n } } class Qc extends an { constructor(t, n, r = "imperative", o = null) { super(t, n), this.type = 0, this.navigationTrigger = r, this.restoredState = o } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class Qn extends an { constructor(t, n, r) { super(t, n), this.urlAfterRedirects = r, this.type = 1 } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class Xs extends an { constructor(t, n, r, o) { super(t, n), this.reason = r, this.code = o, this.type = 2 } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class mD extends an { constructor(t, n, r, o) { super(t, n), this.error = r, this.target = o, this.type = 3 } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class ZR extends an { constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.type = 4 } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class JR extends an { constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.type = 7 } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class YR extends an { constructor(t, n, r, o, i) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.shouldActivate = i, this.type = 8 } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class XR extends an { constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.type = 5 } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class eN extends an { constructor(t, n, r, o) { super(t, n), this.urlAfterRedirects = r, this.state = o, this.type = 6 } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class tN { constructor(t) { this.route = t, this.type = 9 } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class nN { constructor(t) { this.route = t, this.type = 10 } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class rN { constructor(t) { this.snapshot = t, this.type = 11 } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class oN { constructor(t) { this.snapshot = t, this.type = 12 } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class iN { constructor(t) { this.snapshot = t, this.type = 13 } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class sN { constructor(t) { this.snapshot = t, this.type = 14 } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class yD { constructor(t, n, r) { this.routerEvent = t, this.position = n, this.anchor = r, this.type = 15 } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } class vD { constructor(t) { this._root = t } get root() { return this._root.value } parent(t) { const n = this.pathFromRoot(t); return n.length > 1 ? n[n.length - 2] : null } children(t) { const n = Zc(t, this._root); return n ? n.children.map(r => r.value) : [] } firstChild(t) { const n = Zc(t, this._root); return n && n.children.length > 0 ? n.children[0].value : null } siblings(t) { const n = Jc(t, this._root); return n.length < 2 ? [] : n[n.length - 2].children.map(o => o.value).filter(o => o !== t) } pathFromRoot(t) { return Jc(t, this._root).map(n => n.value) } } function Zc(e, t) { if (e === t.value) return t; for (const n of t.children) { const r = Zc(e, n); if (r) return r } return null } function Jc(e, t) { if (e === t.value) return [t]; for (const n of t.children) { const r = Jc(e, n); if (r.length) return r.unshift(t), r } return [] } class un { constructor(t, n) { this.value = t, this.children = n } toString() { return `TreeNode(${this.value})` } } function Ur(e) { const t = {}; return e && e.children.forEach(n => t[n.value.outlet] = n), t } class DD extends vD { constructor(t, n) { super(t), this.snapshot = n, Yc(this, t) } toString() { return this.snapshot.toString() } } function wD(e, t) { const n = function uN(e, t) { const s = new ea([], {}, {}, "", {}, $, t, null, e.root, -1, {}); return new _D("", new un(s, [])) }(e, t), r = new Tt([new Jo("", {})]), o = new Tt({}), i = new Tt({}), s = new Tt({}), a = new Tt(""), u = new Zn(r, o, s, a, i, $, t, n.root); return u.snapshot = n.root, new DD(new un(u, []), n) } class Zn { constructor(t, n, r, o, i, s, a, u) { this.url = t, this.params = n, this.queryParams = r, this.fragment = o, this.data = i, this.outlet = s, this.component = a, this.title = this.data?.pipe(B(l => l[Zo])) ?? M(void 0), this._futureSnapshot = u } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe(B(t => $r(t)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe(B(t => $r(t)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function CD(e, t = "emptyOnly") { const n = e.pathFromRoot; let r = 0; if ("always" !== t) for (r = n.length - 1; r >= 1;) { const o = n[r], i = n[r - 1]; if (o.routeConfig && "" === o.routeConfig.path) r--; else { if (i.component) break; r-- } } return function lN(e) { return e.reduce((t, n) => ({ params: { ...t.params, ...n.params }, data: { ...t.data, ...n.data }, resolve: { ...n.data, ...t.resolve, ...n.routeConfig?.data, ...n._resolvedData } }), { params: {}, data: {}, resolve: {} }) }(n.slice(r)) } class ea { constructor(t, n, r, o, i, s, a, u, l, c, d, f) { this.url = t, this.params = n, this.queryParams = r, this.fragment = o, this.data = i, this.outlet = s, this.component = a, this.title = this.data?.[Zo], this.routeConfig = u, this._urlSegment = l, this._lastPathIndex = c, this._correctedLastPathIndex = f ?? c, this._resolve = d } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = $r(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = $r(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(r => r.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class _D extends vD { constructor(t, n) { super(n), this.url = t, Yc(this, n) } toString() { return ED(this._root) } } function Yc(e, t) { t.value._routerState = e, t.children.forEach(n => Yc(e, n)) } function ED(e) { const t = e.children.length > 0 ? ` { ${e.children.map(ED).join(", ")} } ` : ""; return `${e.value}${t}` } function Xc(e) { if (e.snapshot) { const t = e.snapshot, n = e._futureSnapshot; e.snapshot = n, $t(t.queryParams, n.queryParams) || e.queryParams.next(n.queryParams), t.fragment !== n.fragment && e.fragment.next(n.fragment), $t(t.params, n.params) || e.params.next(n.params), function bR(e, t) { if (e.length !== t.length) return !1; for (let n = 0; n < e.length; ++n)if (!$t(e[n], t[n])) return !1; return !0 }(t.url, n.url) || e.url.next(n.url), $t(t.data, n.data) || e.data.next(n.data) } else e.snapshot = e._futureSnapshot, e.data.next(e._futureSnapshot.data) } function ed(e, t) { const n = $t(e.params, t.params) && function AR(e, t) { return qn(e, t) && e.every((n, r) => $t(n.parameters, t[r].parameters)) }(e.url, t.url); return n && !(!e.parent != !t.parent) && (!e.parent || ed(e.parent, t.parent)) } function ni(e, t, n) { if (n && e.shouldReuseRoute(t.value, n.value.snapshot)) { const r = n.value; r._futureSnapshot = t.value; const o = function dN(e, t, n) { return t.children.map(r => { for (const o of n.children) if (e.shouldReuseRoute(r.value, o.value.snapshot)) return ni(e, r, o); return ni(e, r) }) }(e, t, n); return new un(r, o) } { if (e.shouldAttach(t.value)) { const i = e.retrieve(t.value); if (null !== i) { const s = i.route; return s.value._futureSnapshot = t.value, s.children = t.children.map(a => ni(e, a)), s } } const r = function fN(e) { return new Zn(new Tt(e.url), new Tt(e.params), new Tt(e.queryParams), new Tt(e.fragment), new Tt(e.data), e.outlet, e.component, e) }(t.value), o = t.children.map(i => ni(e, i)); return new un(r, o) } } const td = "ngNavigationCancelingError"; function bD(e, t) { const { redirectTo: n, navigationBehaviorOptions: r } = Kn(t) ? { redirectTo: t, navigationBehaviorOptions: void 0 } : t, o = ID(!1, 0, t); return o.url = n, o.navigationBehaviorOptions = r, o } function ID(e, t, n) { const r = new Error("NavigationCancelingError: " + (e || "")); return r[td] = !0, r.cancellationCode = t, n && (r.url = n), r } function SD(e) { return MD(e) && Kn(e.url) } function MD(e) { return e && e[td] } class hN { constructor() { this.outlet = null, this.route = null, this.resolver = null, this.injector = null, this.children = new ri, this.attachRef = null } } let ri = (() => { class e { constructor() { this.contexts = new Map } onChildOutletCreated(n, r) { const o = this.getOrCreateContext(n); o.outlet = r, this.contexts.set(n, o) } onChildOutletDestroyed(n) { const r = this.getContext(n); r && (r.outlet = null, r.attachRef = null) } onOutletDeactivated() { const n = this.contexts; return this.contexts = new Map, n } onOutletReAttached(n) { this.contexts = n } getOrCreateContext(n) { let r = this.getContext(n); return r || (r = new hN, this.contexts.set(n, r)), r } getContext(n) { return this.contexts.get(n) || null } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const ta = !1; let nd = (() => { class e { constructor(n, r, o, i, s) { this.parentContexts = n, this.location = r, this.changeDetector = i, this.environmentInjector = s, this.activated = null, this._activatedRoute = null, this.activateEvents = new Ue, this.deactivateEvents = new Ue, this.attachEvents = new Ue, this.detachEvents = new Ue, this.name = o || $, n.onChildOutletCreated(this.name, this) } ngOnDestroy() { this.parentContexts.getContext(this.name)?.outlet === this && this.parentContexts.onChildOutletDestroyed(this.name) } ngOnInit() { if (!this.activated) { const n = this.parentContexts.getContext(this.name); n && n.route && (n.attachRef ? this.attach(n.attachRef, n.route) : this.activateWith(n.route, n.injector)) } } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new E(4012, ta); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new E(4012, ta); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new E(4012, ta); this.location.detach(); const n = this.activated; return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(n.instance), n } attach(n, r) { this.activated = n, this._activatedRoute = r, this.location.insert(n.hostView), this.attachEvents.emit(n.instance) } deactivate() { if (this.activated) { const n = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(n) } } activateWith(n, r) { if (this.isActivated) throw new E(4013, ta); this._activatedRoute = n; const o = this.location, s = n._futureSnapshot.component, a = this.parentContexts.getOrCreateContext(this.name).children, u = new pN(n, a, o.injector); if (r && function gN(e) { return !!e.resolveComponentFactory }(r)) { const l = r.resolveComponentFactory(s); this.activated = o.createComponent(l, o.length, u) } else this.activated = o.createComponent(s, { index: o.length, injector: u, environmentInjector: r ?? this.environmentInjector }); this.changeDetector.markForCheck(), this.activateEvents.emit(this.activated.instance) } } return e.\u0275fac = function (n) { return new (n || e)(I(ri), I(bt), function ao(e) { return function qC(e, t) { if ("class" === t) return e.classes; if ("style" === t) return e.styles; const n = e.attrs; if (n) { const r = n.length; let o = 0; for (; o < r;) { const i = n[o]; if (Sf(i)) break; if (0 === i) o += 2; else if ("number" == typeof i) for (o++; o < r && "string" == typeof n[o];)o++; else { if (i === t) return n[o + 1]; o += 2 } } } return null }(De(), e) }("name"), I(nc), I(pn)) }, e.\u0275dir = xe({ type: e, selectors: [["router-outlet"]], outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"], standalone: !0 }), e })(); class pN { constructor(t, n, r) { this.route = t, this.childContexts = n, this.parent = r } get(t, n) { return t === Zn ? this.route : t === ri ? this.childContexts : this.parent.get(t, n) } } let rd = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = xn({ type: e, selectors: [["ng-component"]], standalone: !0, features: [Mm], decls: 1, vars: 0, template: function (n, r) { 1 & n && Ct(0, "router-outlet") }, dependencies: [nd], encapsulation: 2 }), e })(); function TD(e, t) { return e.providers && !e._injector && (e._injector = ms(e.providers, t, `Route: ${e.path}`)), e._injector ?? t } function id(e) { const t = e.children && e.children.map(id), n = t ? { ...e, children: t } : { ...e }; return !n.component && !n.loadComponent && (t || n.loadChildren) && n.outlet && n.outlet !== $ && (n.component = rd), n } function pt(e) { return e.outlet || $ } function AD(e, t) { const n = e.filter(r => pt(r) === t); return n.push(...e.filter(r => pt(r) !== t)), n } function oi(e) { if (!e) return null; if (e.routeConfig?._injector) return e.routeConfig._injector; for (let t = e.parent; t; t = t.parent) { const n = t.routeConfig; if (n?._loadedInjector) return n._loadedInjector; if (n?._injector) return n._injector } return null } class wN { constructor(t, n, r, o) { this.routeReuseStrategy = t, this.futureState = n, this.currState = r, this.forwardEvent = o } activate(t) { const n = this.futureState._root, r = this.currState ? this.currState._root : null; this.deactivateChildRoutes(n, r, t), Xc(this.futureState.root), this.activateChildRoutes(n, r, t) } deactivateChildRoutes(t, n, r) { const o = Ur(n); t.children.forEach(i => { const s = i.value.outlet; this.deactivateRoutes(i, o[s], r), delete o[s] }), Te(o, (i, s) => { this.deactivateRouteAndItsChildren(i, r) }) } deactivateRoutes(t, n, r) { const o = t.value, i = n ? n.value : null; if (o === i) if (o.component) { const s = r.getContext(o.outlet); s && this.deactivateChildRoutes(t, n, s.children) } else this.deactivateChildRoutes(t, n, r); else i && this.deactivateRouteAndItsChildren(n, r) } deactivateRouteAndItsChildren(t, n) { t.value.component && this.routeReuseStrategy.shouldDetach(t.value.snapshot) ? this.detachAndStoreRouteSubtree(t, n) : this.deactivateRouteAndOutlet(t, n) } detachAndStoreRouteSubtree(t, n) { const r = n.getContext(t.value.outlet), o = r && t.value.component ? r.children : n, i = Ur(t); for (const s of Object.keys(i)) this.deactivateRouteAndItsChildren(i[s], o); if (r && r.outlet) { const s = r.outlet.detach(), a = r.children.onOutletDeactivated(); this.routeReuseStrategy.store(t.value.snapshot, { componentRef: s, route: t, contexts: a }) } } deactivateRouteAndOutlet(t, n) { const r = n.getContext(t.value.outlet), o = r && t.value.component ? r.children : n, i = Ur(t); for (const s of Object.keys(i)) this.deactivateRouteAndItsChildren(i[s], o); r && r.outlet && (r.outlet.deactivate(), r.children.onOutletDeactivated(), r.attachRef = null, r.resolver = null, r.route = null) } activateChildRoutes(t, n, r) { const o = Ur(n); t.children.forEach(i => { this.activateRoutes(i, o[i.value.outlet], r), this.forwardEvent(new sN(i.value.snapshot)) }), t.children.length && this.forwardEvent(new oN(t.value.snapshot)) } activateRoutes(t, n, r) { const o = t.value, i = n ? n.value : null; if (Xc(o), o === i) if (o.component) { const s = r.getOrCreateContext(o.outlet); this.activateChildRoutes(t, n, s.children) } else this.activateChildRoutes(t, n, r); else if (o.component) { const s = r.getOrCreateContext(o.outlet); if (this.routeReuseStrategy.shouldAttach(o.snapshot)) { const a = this.routeReuseStrategy.retrieve(o.snapshot); this.routeReuseStrategy.store(o.snapshot, null), s.children.onOutletReAttached(a.contexts), s.attachRef = a.componentRef, s.route = a.route.value, s.outlet && s.outlet.attach(a.componentRef, a.route.value), Xc(a.route.value), this.activateChildRoutes(t, null, s.children) } else { const a = oi(o.snapshot), u = a?.get(_o) ?? null; s.attachRef = null, s.route = o, s.resolver = u, s.injector = a, s.outlet && s.outlet.activateWith(o, s.injector), this.activateChildRoutes(t, null, s.children) } } else this.activateChildRoutes(t, null, r) } } class xD { constructor(t) { this.path = t, this.route = this.path[this.path.length - 1] } } class na { constructor(t, n) { this.component = t, this.route = n } } function CN(e, t, n) { const r = e._root; return ii(r, t ? t._root : null, n, [r.value]) } function zr(e, t) { const n = Symbol(), r = t.get(e, n); return r === n ? "function" != typeof e || function Kw(e) { return null !== gi(e) }(e) ? t.get(e) : e : r } function ii(e, t, n, r, o = { canDeactivateChecks: [], canActivateChecks: [] }) { const i = Ur(t); return e.children.forEach(s => { (function EN(e, t, n, r, o = { canDeactivateChecks: [], canActivateChecks: [] }) { const i = e.value, s = t ? t.value : null, a = n ? n.getContext(e.value.outlet) : null; if (s && i.routeConfig === s.routeConfig) { const u = function bN(e, t, n) { if ("function" == typeof n) return n(e, t); switch (n) { case "pathParamsChange": return !qn(e.url, t.url); case "pathParamsOrQueryParamsChange": return !qn(e.url, t.url) || !$t(e.queryParams, t.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !ed(e, t) || !$t(e.queryParams, t.queryParams); default: return !ed(e, t) } }(s, i, i.routeConfig.runGuardsAndResolvers); u ? o.canActivateChecks.push(new xD(r)) : (i.data = s.data, i._resolvedData = s._resolvedData), ii(e, t, i.component ? a ? a.children : null : n, r, o), u && a && a.outlet && a.outlet.isActivated && o.canDeactivateChecks.push(new na(a.outlet.component, s)) } else s && si(t, a, o), o.canActivateChecks.push(new xD(r)), ii(e, null, i.component ? a ? a.children : null : n, r, o) })(s, i[s.value.outlet], n, r.concat([s.value]), o), delete i[s.value.outlet] }), Te(i, (s, a) => si(s, n.getContext(a), o)), o } function si(e, t, n) { const r = Ur(e), o = e.value; Te(r, (i, s) => { si(i, o.component ? t ? t.children.getContext(s) : null : t, n) }), n.canDeactivateChecks.push(new na(o.component && t && t.outlet && t.outlet.isActivated ? t.outlet.component : null, o)) } function ai(e) { return "function" == typeof e } function sd(e) { return e instanceof Gs || "EmptyError" === e?.name } const ra = Symbol("INITIAL_VALUE"); function Gr() { return Vt(e => Gv(e.map(t => t.pipe(Qo(1), function yR(...e) { const t = Zr(e); return be((n, r) => { (t ? jc(e, n, t) : jc(e, n)).subscribe(r) }) }(ra)))).pipe(B(t => { for (const n of t) if (!0 !== n) { if (n === ra) return ra; if (!1 === n || n instanceof Wn) return n } return !0 }), on(t => t !== ra), Qo(1))) } function RD(e) { return function fw(...e) { return Rd(e) }(ke(t => { if (Kn(t)) throw bD(0, t) }), B(t => !0 === t)) } const ad = { matched: !1, consumedSegments: [], remainingSegments: [], parameters: {}, positionalParamSegments: {} }; function ND(e, t, n, r, o) { const i = ud(e, t, n); return i.matched ? function HN(e, t, n, r) { const o = t.canMatch; return o && 0 !== o.length ? M(o.map(s => { const a = zr(s, e); return In(function xN(e) { return e && ai(e.canMatch) }(a) ? a.canMatch(t, n) : e.runInContext(() => a(t, n))) })).pipe(Gr(), RD()) : M(!0) }(r = TD(t, r), t, n).pipe(B(s => !0 === s ? i : { ...ad })) : M(i) } function ud(e, t, n) { if ("" === t.path) return "full" === t.pathMatch && (e.hasChildren() || n.length > 0) ? { ...ad } : { matched: !0, consumedSegments: [], remainingSegments: n, parameters: {}, positionalParamSegments: {} }; const o = (t.matcher || ER)(n, e, t); if (!o) return { ...ad }; const i = {}; Te(o.posParams, (a, u) => { i[u] = a.path }); const s = o.consumed.length > 0 ? { ...i, ...o.consumed[o.consumed.length - 1].parameters } : i; return { matched: !0, consumedSegments: o.consumed, remainingSegments: n.slice(o.consumed.length), parameters: s, positionalParamSegments: o.posParams ?? {} } } function oa(e, t, n, r, o = "corrected") { if (n.length > 0 && function zN(e, t, n) { return n.some(r => ia(e, t, r) && pt(r) !== $) }(e, n, r)) { const s = new H(t, function UN(e, t, n, r) { const o = {}; o[$] = r, r._sourceSegment = e, r._segmentIndexShift = t.length; for (const i of n) if ("" === i.path && pt(i) !== $) { const s = new H([], {}); s._sourceSegment = e, s._segmentIndexShift = t.length, o[pt(i)] = s } return o }(e, t, r, new H(n, e.children))); return s._sourceSegment = e, s._segmentIndexShift = t.length, { segmentGroup: s, slicedSegments: [] } } if (0 === n.length && function GN(e, t, n) { return n.some(r => ia(e, t, r)) }(e, n, r)) { const s = new H(e.segments, function BN(e, t, n, r, o, i) { const s = {}; for (const a of r) if (ia(e, n, a) && !o[pt(a)]) { const u = new H([], {}); u._sourceSegment = e, u._segmentIndexShift = "legacy" === i ? e.segments.length : t.length, s[pt(a)] = u } return { ...o, ...s } }(e, t, n, r, e.children, o)); return s._sourceSegment = e, s._segmentIndexShift = t.length, { segmentGroup: s, slicedSegments: n } } const i = new H(e.segments, e.children); return i._sourceSegment = e, i._segmentIndexShift = t.length, { segmentGroup: i, slicedSegments: n } } function ia(e, t, n) { return (!(e.hasChildren() || t.length > 0) || "full" !== n.pathMatch) && "" === n.path } function PD(e, t, n, r) { return !!(pt(e) === r || r !== $ && ia(t, n, e)) && ("**" === e.path || ud(t, e, n).matched) } function OD(e, t, n) { return 0 === t.length && !e.children[n] } const sa = !1; class aa { constructor(t) { this.segmentGroup = t || null } } class FD { constructor(t) { this.urlTree = t } } function ui(e) { return Ko(new aa(e)) } function kD(e) { return Ko(new FD(e)) } class QN { constructor(t, n, r, o, i) { this.injector = t, this.configLoader = n, this.urlSerializer = r, this.urlTree = o, this.config = i, this.allowRedirects = !0 } apply() { const t = oa(this.urlTree.root, [], [], this.config).segmentGroup, n = new H(t.segments, t.children); return this.expandSegmentGroup(this.injector, this.config, n, $).pipe(B(i => this.createUrlTree(Ys(i), this.urlTree.queryParams, this.urlTree.fragment))).pipe(bn(i => { if (i instanceof FD) return this.allowRedirects = !1, this.match(i.urlTree); throw i instanceof aa ? this.noMatchError(i) : i })) } match(t) { return this.expandSegmentGroup(this.injector, this.config, t.root, $).pipe(B(o => this.createUrlTree(Ys(o), t.queryParams, t.fragment))).pipe(bn(o => { throw o instanceof aa ? this.noMatchError(o) : o })) } noMatchError(t) { return new E(4002, sa) } createUrlTree(t, n, r) { const o = Gc(t); return new Wn(o, n, r) } expandSegmentGroup(t, n, r, o) { return 0 === r.segments.length && r.hasChildren() ? this.expandChildren(t, n, r).pipe(B(i => new H([], i))) : this.expandSegment(t, r, n, r.segments, o, !0) } expandChildren(t, n, r) { const o = []; for (const i of Object.keys(r.children)) "primary" === i ? o.unshift(i) : o.push(i); return ve(o).pipe(Cn(i => { const s = r.children[i], a = AD(n, i); return this.expandSegmentGroup(t, a, s, i).pipe(B(u => ({ segment: u, outlet: i }))) }), Zv((i, s) => (i[s.outlet] = s.segment, i), {}), Jv()) } expandSegment(t, n, r, o, i, s) { return ve(r).pipe(Cn(a => this.expandSegmentAgainstRoute(t, n, r, a, o, i, s).pipe(bn(l => { if (l instanceof aa) return M(null); throw l }))), En(a => !!a), bn((a, u) => { if (sd(a)) return OD(n, o, i) ? M(new H([], {})) : ui(n); throw a })) } expandSegmentAgainstRoute(t, n, r, o, i, s, a) { return PD(o, n, i, s) ? void 0 === o.redirectTo ? this.matchSegmentAgainstRoute(t, n, o, i, s) : a && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(t, n, r, o, i, s) : ui(n) : ui(n) } expandSegmentAgainstRouteUsingRedirect(t, n, r, o, i, s) { return "**" === o.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(t, r, o, s) : this.expandRegularSegmentAgainstRouteUsingRedirect(t, n, r, o, i, s) } expandWildCardWithParamsAgainstRouteUsingRedirect(t, n, r, o) { const i = this.applyRedirectCommands([], r.redirectTo, {}); return r.redirectTo.startsWith("/") ? kD(i) : this.lineralizeSegments(r, i).pipe(Me(s => { const a = new H(s, {}); return this.expandSegment(t, a, n, s, o, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(t, n, r, o, i, s) { const { matched: a, consumedSegments: u, remainingSegments: l, positionalParamSegments: c } = ud(n, o, i); if (!a) return ui(n); const d = this.applyRedirectCommands(u, o.redirectTo, c); return o.redirectTo.startsWith("/") ? kD(d) : this.lineralizeSegments(o, d).pipe(Me(f => this.expandSegment(t, n, r, f.concat(l), s, !1))) } matchSegmentAgainstRoute(t, n, r, o, i) { return "**" === r.path ? (t = TD(r, t), r.loadChildren ? (r._loadedRoutes ? M({ routes: r._loadedRoutes, injector: r._loadedInjector }) : this.configLoader.loadChildren(t, r)).pipe(B(a => (r._loadedRoutes = a.routes, r._loadedInjector = a.injector, new H(o, {})))) : M(new H(o, {}))) : ND(n, r, o, t).pipe(Vt(({ matched: s, consumedSegments: a, remainingSegments: u }) => s ? this.getChildConfig(t = r._injector ?? t, r, o).pipe(Me(c => { const d = c.injector ?? t, f = c.routes, { segmentGroup: h, slicedSegments: p } = oa(n, a, u, f), g = new H(h.segments, h.children); if (0 === p.length && g.hasChildren()) return this.expandChildren(d, f, g).pipe(B(m => new H(a, m))); if (0 === f.length && 0 === p.length) return M(new H(a, {})); const y = pt(r) === i; return this.expandSegment(d, g, f, p, y ? $ : i, !0).pipe(B(w => new H(a.concat(w.segments), w.children))) })) : ui(n))) } getChildConfig(t, n, r) { return n.children ? M({ routes: n.children, injector: t }) : n.loadChildren ? void 0 !== n._loadedRoutes ? M({ routes: n._loadedRoutes, injector: n._loadedInjector }) : function $N(e, t, n, r) { const o = t.canLoad; return void 0 === o || 0 === o.length ? M(!0) : M(o.map(s => { const a = zr(s, e); return In(function SN(e) { return e && ai(e.canLoad) }(a) ? a.canLoad(t, n) : e.runInContext(() => a(t, n))) })).pipe(Gr(), RD()) }(t, n, r).pipe(Me(o => o ? this.configLoader.loadChildren(t, n).pipe(ke(i => { n._loadedRoutes = i.routes, n._loadedInjector = i.injector })) : function qN(e) { return Ko(ID(sa, 3)) }())) : M({ routes: [], injector: t }) } lineralizeSegments(t, n) { let r = [], o = n.root; for (; ;) { if (r = r.concat(o.segments), 0 === o.numberOfChildren) return M(r); if (o.numberOfChildren > 1 || !o.children[$]) return Ko(new E(4e3, sa)); o = o.children[$] } } applyRedirectCommands(t, n, r) { return this.applyRedirectCreateUrlTree(n, this.urlSerializer.parse(n), t, r) } applyRedirectCreateUrlTree(t, n, r, o) { const i = this.createSegmentGroup(t, n.root, r, o); return new Wn(i, this.createQueryParams(n.queryParams, this.urlTree.queryParams), n.fragment) } createQueryParams(t, n) { const r = {}; return Te(t, (o, i) => { if ("string" == typeof o && o.startsWith(":")) { const a = o.substring(1); r[i] = n[a] } else r[i] = o }), r } createSegmentGroup(t, n, r, o) { const i = this.createSegments(t, n.segments, r, o); let s = {}; return Te(n.children, (a, u) => { s[u] = this.createSegmentGroup(t, a, r, o) }), new H(i, s) } createSegments(t, n, r, o) { return n.map(i => i.path.startsWith(":") ? this.findPosParam(t, i, o) : this.findOrReturn(i, r)) } findPosParam(t, n, r) { const o = r[n.path.substring(1)]; if (!o) throw new E(4001, sa); return o } findOrReturn(t, n) { let r = 0; for (const o of n) { if (o.path === t.path) return n.splice(r), o; r++ } return t } } class JN { } class eP { constructor(t, n, r, o, i, s, a, u) { this.injector = t, this.rootComponentType = n, this.config = r, this.urlTree = o, this.url = i, this.paramsInheritanceStrategy = s, this.relativeLinkResolution = a, this.urlSerializer = u } recognize() { const t = oa(this.urlTree.root, [], [], this.config.filter(n => void 0 === n.redirectTo), this.relativeLinkResolution).segmentGroup; return this.processSegmentGroup(this.injector, this.config, t, $).pipe(B(n => { if (null === n) return null; const r = new ea([], Object.freeze({}), Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, {}, $, this.rootComponentType, null, this.urlTree.root, -1, {}), o = new un(r, n), i = new _D(this.url, o); return this.inheritParamsAndData(i._root), i })) } inheritParamsAndData(t) { const n = t.value, r = CD(n, this.paramsInheritanceStrategy); n.params = Object.freeze(r.params), n.data = Object.freeze(r.data), t.children.forEach(o => this.inheritParamsAndData(o)) } processSegmentGroup(t, n, r, o) { return 0 === r.segments.length && r.hasChildren() ? this.processChildren(t, n, r) : this.processSegment(t, n, r, r.segments, o) } processChildren(t, n, r) { return ve(Object.keys(r.children)).pipe(Cn(o => { const i = r.children[o], s = AD(n, o); return this.processSegmentGroup(t, s, i, o) }), Zv((o, i) => o && i ? (o.push(...i), o) : null), function wR(e, t = !1) { return be((n, r) => { let o = 0; n.subscribe(Ie(r, i => { const s = e(i, o++); (s || t) && r.next(i), !s && r.complete() })) }) }(o => null !== o), Ws(null), Jv(), B(o => { if (null === o) return null; const i = LD(o); return function tP(e) { e.sort((t, n) => t.value.outlet === $ ? -1 : n.value.outlet === $ ? 1 : t.value.outlet.localeCompare(n.value.outlet)) }(i), i })) } processSegment(t, n, r, o, i) { return ve(n).pipe(Cn(s => this.processSegmentAgainstRoute(s._injector ?? t, s, r, o, i)), En(s => !!s), bn(s => { if (sd(s)) return OD(r, o, i) ? M([]) : M(null); throw s })) } processSegmentAgainstRoute(t, n, r, o, i) { if (n.redirectTo || !PD(n, r, o, i)) return M(null); let s; if ("**" === n.path) { const a = o.length > 0 ? eD(o).parameters : {}, u = VD(r) + o.length; s = M({ snapshot: new ea(o, a, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, HD(n), pt(n), n.component ?? n._loadedComponent ?? null, n, jD(r), u, BD(n), u), consumedSegments: [], remainingSegments: [] }) } else s = ND(r, n, o, t).pipe(B(({ matched: a, consumedSegments: u, remainingSegments: l, parameters: c }) => { if (!a) return null; const d = VD(r) + u.length; return { snapshot: new ea(u, c, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, HD(n), pt(n), n.component ?? n._loadedComponent ?? null, n, jD(r), d, BD(n), d), consumedSegments: u, remainingSegments: l } })); return s.pipe(Vt(a => { if (null === a) return M(null); const { snapshot: u, consumedSegments: l, remainingSegments: c } = a; t = n._injector ?? t; const d = n._loadedInjector ?? t, f = function nP(e) { return e.children ? e.children : e.loadChildren ? e._loadedRoutes : [] }(n), { segmentGroup: h, slicedSegments: p } = oa(r, l, c, f.filter(y => void 0 === y.redirectTo), this.relativeLinkResolution); if (0 === p.length && h.hasChildren()) return this.processChildren(d, f, h).pipe(B(y => null === y ? null : [new un(u, y)])); if (0 === f.length && 0 === p.length) return M([new un(u, [])]); const g = pt(n) === i; return this.processSegment(d, f, h, p, g ? $ : i).pipe(B(y => null === y ? null : [new un(u, y)])) })) } } function rP(e) { const t = e.value.routeConfig; return t && "" === t.path && void 0 === t.redirectTo } function LD(e) { const t = [], n = new Set; for (const r of e) { if (!rP(r)) { t.push(r); continue } const o = t.find(i => r.value.routeConfig === i.value.routeConfig); void 0 !== o ? (o.children.push(...r.children), n.add(o)) : t.push(r) } for (const r of n) { const o = LD(r.children); t.push(new un(r.value, o)) } return t.filter(r => !n.has(r)) } function jD(e) { let t = e; for (; t._sourceSegment;)t = t._sourceSegment; return t } function VD(e) { let t = e, n = t._segmentIndexShift ?? 0; for (; t._sourceSegment;)t = t._sourceSegment, n += t._segmentIndexShift ?? 0; return n - 1 } function HD(e) { return e.data || {} } function BD(e) { return e.resolve || {} } function UD(e) { return "string" == typeof e.title || null === e.title } function ld(e) { return Vt(t => { const n = e(t); return n ? ve(n).pipe(B(() => t)) : M(t) }) } let zD = (() => { class e { buildTitle(n) { let r, o = n.root; for (; void 0 !== o;)r = this.getResolvedTitleForRoute(o) ?? r, o = o.children.find(i => i.outlet === $); return r } getResolvedTitleForRoute(n) { return n.data[Zo] } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275prov = N({ token: e, factory: function () { return ue(GD) }, providedIn: "root" }), e })(), GD = (() => { class e extends zD { constructor(n) { super(), this.title = n } updateTitle(n) { const r = this.buildTitle(n); void 0 !== r && this.title.setTitle(r) } } return e.\u0275fac = function (n) { return new (n || e)(b(xv)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); class dP { } class hP extends class fP { shouldDetach(t) { return !1 } store(t, n) { } shouldAttach(t) { return !1 } retrieve(t) { return null } shouldReuseRoute(t, n) { return t.routeConfig === n.routeConfig } }{ } const la = new P("", { providedIn: "root", factory: () => ({}) }), cd = new P("ROUTES"); let dd = (() => { class e { constructor(n, r) { this.injector = n, this.compiler = r, this.componentLoaders = new WeakMap, this.childrenLoaders = new WeakMap } loadComponent(n) { if (this.componentLoaders.get(n)) return this.componentLoaders.get(n); if (n._loadedComponent) return M(n._loadedComponent); this.onLoadStartListener && this.onLoadStartListener(n); const r = In(n.loadComponent()).pipe(ke(i => { this.onLoadEndListener && this.onLoadEndListener(n), n._loadedComponent = i }), Hc(() => { this.componentLoaders.delete(n) })), o = new Kv(r, () => new At).pipe(Vc()); return this.componentLoaders.set(n, o), o } loadChildren(n, r) { if (this.childrenLoaders.get(r)) return this.childrenLoaders.get(r); if (r._loadedRoutes) return M({ routes: r._loadedRoutes, injector: r._loadedInjector }); this.onLoadStartListener && this.onLoadStartListener(r); const i = this.loadModuleFactoryOrRoutes(r.loadChildren).pipe(B(a => { this.onLoadEndListener && this.onLoadEndListener(r); let u, l, c = !1; Array.isArray(a) ? l = a : (u = a.create(n).injector, l = Xv(u.get(cd, [], A.Self | A.Optional))); return { routes: l.map(id), injector: u } }), Hc(() => { this.childrenLoaders.delete(r) })), s = new Kv(i, () => new At).pipe(Vc()); return this.childrenLoaders.set(r, s), s } loadModuleFactoryOrRoutes(n) { return In(n()).pipe(Me(r => r instanceof Im || Array.isArray(r) ? M(r) : ve(this.compiler.compileModuleAsync(r)))) } } return e.\u0275fac = function (n) { return new (n || e)(b(lt), b(ql)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); class gP { } class mP { shouldProcessUrl(t) { return !0 } extract(t) { return t } merge(t, n) { return t } } function yP(e) { throw e } function vP(e, t, n) { return t.parse("/") } const DP = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, wP = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }; function qD() { const e = ue(sD), t = ue(ri), n = ue(lc), r = ue(lt), o = ue(ql), i = ue(cd, { optional: !0 }) ?? [], s = ue(la, { optional: !0 }) ?? {}, a = ue(GD), u = ue(zD, { optional: !0 }), l = ue(gP, { optional: !0 }), c = ue(dP, { optional: !0 }), d = new Ae(null, e, t, n, r, o, Xv(i)); return l && (d.urlHandlingStrategy = l), c && (d.routeReuseStrategy = c), d.titleStrategy = u ?? a, function CP(e, t) { e.errorHandler && (t.errorHandler = e.errorHandler), e.malformedUriErrorHandler && (t.malformedUriErrorHandler = e.malformedUriErrorHandler), e.onSameUrlNavigation && (t.onSameUrlNavigation = e.onSameUrlNavigation), e.paramsInheritanceStrategy && (t.paramsInheritanceStrategy = e.paramsInheritanceStrategy), e.relativeLinkResolution && (t.relativeLinkResolution = e.relativeLinkResolution), e.urlUpdateStrategy && (t.urlUpdateStrategy = e.urlUpdateStrategy), e.canceledNavigationResolution && (t.canceledNavigationResolution = e.canceledNavigationResolution) }(s, d), d } let Ae = (() => { class e { constructor(n, r, o, i, s, a, u) { this.rootComponentType = n, this.urlSerializer = r, this.rootContexts = o, this.location = i, this.config = u, this.lastSuccessfulNavigation = null, this.currentNavigation = null, this.disposed = !1, this.navigationId = 0, this.currentPageId = 0, this.isNgZoneEnabled = !1, this.events = new At, this.errorHandler = yP, this.malformedUriErrorHandler = vP, this.navigated = !1, this.lastSuccessfulId = -1, this.afterPreactivation = () => M(void 0), this.urlHandlingStrategy = new mP, this.routeReuseStrategy = new hP, this.onSameUrlNavigation = "ignore", this.paramsInheritanceStrategy = "emptyOnly", this.urlUpdateStrategy = "deferred", this.relativeLinkResolution = "corrected", this.canceledNavigationResolution = "replace", this.configLoader = s.get(dd), this.configLoader.onLoadEndListener = f => this.triggerEvent(new nN(f)), this.configLoader.onLoadStartListener = f => this.triggerEvent(new tN(f)), this.ngModule = s.get(Un), this.console = s.get(jM); const d = s.get(_e); this.isNgZoneEnabled = d instanceof _e && _e.isInAngularZone(), this.resetConfig(u), this.currentUrlTree = function IR() { return new Wn(new H([], {}), {}, null) }(), this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.routerState = wD(this.currentUrlTree, this.rootComponentType), this.transitions = new Tt({ id: 0, targetPageId: 0, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, extractedUrl: this.urlHandlingStrategy.extract(this.currentUrlTree), urlAfterRedirects: this.urlHandlingStrategy.extract(this.currentUrlTree), rawUrl: this.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: "imperative", restoredState: null, currentSnapshot: this.routerState.snapshot, targetSnapshot: null, currentRouterState: this.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.navigations = this.setupNavigations(this.transitions), this.processNavigations() } get browserPageId() { return this.location.getState()?.\u0275routerPageId } setupNavigations(n) { const r = this.events; return n.pipe(on(o => 0 !== o.id), B(o => ({ ...o, extractedUrl: this.urlHandlingStrategy.extract(o.rawUrl) })), Vt(o => { let i = !1, s = !1; return M(o).pipe(ke(a => { this.currentNavigation = { id: a.id, initialUrl: a.rawUrl, extractedUrl: a.extractedUrl, trigger: a.source, extras: a.extras, previousNavigation: this.lastSuccessfulNavigation ? { ...this.lastSuccessfulNavigation, previousNavigation: null } : null } }), Vt(a => { const u = this.browserUrlTree.toString(), l = !this.navigated || a.extractedUrl.toString() !== u || u !== this.currentUrlTree.toString(); if (("reload" === this.onSameUrlNavigation || l) && this.urlHandlingStrategy.shouldProcessUrl(a.rawUrl)) return KD(a.source) && (this.browserUrlTree = a.extractedUrl), M(a).pipe(Vt(d => { const f = this.transitions.getValue(); return r.next(new Qc(d.id, this.serializeUrl(d.extractedUrl), d.source, d.restoredState)), f !== this.transitions.getValue() ? Bt : Promise.resolve(d) }), function ZN(e, t, n, r) { return Vt(o => function KN(e, t, n, r, o) { return new QN(e, t, n, r, o).apply() }(e, t, n, o.extractedUrl, r).pipe(B(i => ({ ...o, urlAfterRedirects: i })))) }(this.ngModule.injector, this.configLoader, this.urlSerializer, this.config), ke(d => { this.currentNavigation = { ...this.currentNavigation, finalUrl: d.urlAfterRedirects }, o.urlAfterRedirects = d.urlAfterRedirects }), function iP(e, t, n, r, o, i) { return Me(s => function XN(e, t, n, r, o, i, s = "emptyOnly", a = "legacy") { return new eP(e, t, n, r, o, s, a, i).recognize().pipe(Vt(u => null === u ? function YN(e) { return new de(t => t.error(e)) }(new JN) : M(u))) }(e, t, n, s.urlAfterRedirects, r.serialize(s.urlAfterRedirects), r, o, i).pipe(B(a => ({ ...s, targetSnapshot: a })))) }(this.ngModule.injector, this.rootComponentType, this.config, this.urlSerializer, this.paramsInheritanceStrategy, this.relativeLinkResolution), ke(d => { if (o.targetSnapshot = d.targetSnapshot, "eager" === this.urlUpdateStrategy) { if (!d.extras.skipLocationChange) { const h = this.urlHandlingStrategy.merge(d.urlAfterRedirects, d.rawUrl); this.setBrowserUrl(h, d) } this.browserUrlTree = d.urlAfterRedirects } const f = new ZR(d.id, this.serializeUrl(d.extractedUrl), this.serializeUrl(d.urlAfterRedirects), d.targetSnapshot); r.next(f) })); if (l && this.rawUrlTree && this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)) { const { id: f, extractedUrl: h, source: p, restoredState: g, extras: y } = a, D = new Qc(f, this.serializeUrl(h), p, g); r.next(D); const w = wD(h, this.rootComponentType).snapshot; return M(o = { ...a, targetSnapshot: w, urlAfterRedirects: h, extras: { ...y, skipLocationChange: !1, replaceUrl: !1 } }) } return this.rawUrlTree = a.rawUrl, a.resolve(null), Bt }), ke(a => { const u = new JR(a.id, this.serializeUrl(a.extractedUrl), this.serializeUrl(a.urlAfterRedirects), a.targetSnapshot); this.triggerEvent(u) }), B(a => o = { ...a, guards: CN(a.targetSnapshot, a.currentSnapshot, this.rootContexts) }), function NN(e, t) { return Me(n => { const { targetSnapshot: r, currentSnapshot: o, guards: { canActivateChecks: i, canDeactivateChecks: s } } = n; return 0 === s.length && 0 === i.length ? M({ ...n, guardsResult: !0 }) : function PN(e, t, n, r) { return ve(e).pipe(Me(o => function VN(e, t, n, r, o) { const i = t && t.routeConfig ? t.routeConfig.canDeactivate : null; return i && 0 !== i.length ? M(i.map(a => { const u = oi(t) ?? o, l = zr(a, u); return In(function AN(e) { return e && ai(e.canDeactivate) }(l) ? l.canDeactivate(e, t, n, r) : u.runInContext(() => l(e, t, n, r))).pipe(En()) })).pipe(Gr()) : M(!0) }(o.component, o.route, n, t, r)), En(o => !0 !== o, !0)) }(s, r, o, e).pipe(Me(a => a && function IN(e) { return "boolean" == typeof e }(a) ? function ON(e, t, n, r) { return ve(t).pipe(Cn(o => jc(function kN(e, t) { return null !== e && t && t(new rN(e)), M(!0) }(o.route.parent, r), function FN(e, t) { return null !== e && t && t(new iN(e)), M(!0) }(o.route, r), function jN(e, t, n) { const r = t[t.length - 1], i = t.slice(0, t.length - 1).reverse().map(s => function _N(e) { const t = e.routeConfig ? e.routeConfig.canActivateChild : null; return t && 0 !== t.length ? { node: e, guards: t } : null }(s)).filter(s => null !== s).map(s => qv(() => M(s.guards.map(u => { const l = oi(s.node) ?? n, c = zr(u, l); return In(function TN(e) { return e && ai(e.canActivateChild) }(c) ? c.canActivateChild(r, e) : l.runInContext(() => c(r, e))).pipe(En()) })).pipe(Gr()))); return M(i).pipe(Gr()) }(e, o.path, n), function LN(e, t, n) { const r = t.routeConfig ? t.routeConfig.canActivate : null; if (!r || 0 === r.length) return M(!0); const o = r.map(i => qv(() => { const s = oi(t) ?? n, a = zr(i, s); return In(function MN(e) { return e && ai(e.canActivate) }(a) ? a.canActivate(t, e) : s.runInContext(() => a(t, e))).pipe(En()) })); return M(o).pipe(Gr()) }(e, o.route, n))), En(o => !0 !== o, !0)) }(r, i, e, t) : M(a)), B(a => ({ ...n, guardsResult: a }))) }) }(this.ngModule.injector, a => this.triggerEvent(a)), ke(a => { if (o.guardsResult = a.guardsResult, Kn(a.guardsResult)) throw bD(0, a.guardsResult); const u = new YR(a.id, this.serializeUrl(a.extractedUrl), this.serializeUrl(a.urlAfterRedirects), a.targetSnapshot, !!a.guardsResult); this.triggerEvent(u) }), on(a => !!a.guardsResult || (this.restoreHistory(a), this.cancelNavigationTransition(a, "", 3), !1)), ld(a => { if (a.guards.canActivateChecks.length) return M(a).pipe(ke(u => { const l = new XR(u.id, this.serializeUrl(u.extractedUrl), this.serializeUrl(u.urlAfterRedirects), u.targetSnapshot); this.triggerEvent(l) }), Vt(u => { let l = !1; return M(u).pipe(function sP(e, t) { return Me(n => { const { targetSnapshot: r, guards: { canActivateChecks: o } } = n; if (!o.length) return M(n); let i = 0; return ve(o).pipe(Cn(s => function aP(e, t, n, r) { const o = e.routeConfig, i = e._resolve; return void 0 !== o?.title && !UD(o) && (i[Zo] = o.title), function uP(e, t, n, r) { const o = function lP(e) { return [...Object.keys(e), ...Object.getOwnPropertySymbols(e)] }(e); if (0 === o.length) return M({}); const i = {}; return ve(o).pipe(Me(s => function cP(e, t, n, r) { const o = oi(t) ?? r, i = zr(e, o); return In(i.resolve ? i.resolve(t, n) : o.runInContext(() => i(t, n))) }(e[s], t, n, r).pipe(En(), ke(a => { i[s] = a }))), $c(1), function CR(e) { return B(() => e) }(i), bn(s => sd(s) ? Bt : Ko(s))) }(i, e, t, r).pipe(B(s => (e._resolvedData = s, e.data = CD(e, n).resolve, o && UD(o) && (e.data[Zo] = o.title), null))) }(s.route, r, e, t)), ke(() => i++), $c(1), Me(s => i === o.length ? M(n) : Bt)) }) }(this.paramsInheritanceStrategy, this.ngModule.injector), ke({ next: () => l = !0, complete: () => { l || (this.restoreHistory(u), this.cancelNavigationTransition(u, "", 2)) } })) }), ke(u => { const l = new eN(u.id, this.serializeUrl(u.extractedUrl), this.serializeUrl(u.urlAfterRedirects), u.targetSnapshot); this.triggerEvent(l) })) }), ld(a => { const u = l => { const c = []; l.routeConfig?.loadComponent && !l.routeConfig._loadedComponent && c.push(this.configLoader.loadComponent(l.routeConfig).pipe(ke(d => { l.component = d }), B(() => { }))); for (const d of l.children) c.push(...u(d)); return c }; return Gv(u(a.targetSnapshot.root)).pipe(Ws(), Qo(1)) }), ld(() => this.afterPreactivation()), B(a => { const u = function cN(e, t, n) { const r = ni(e, t._root, n ? n._root : void 0); return new DD(r, t) }(this.routeReuseStrategy, a.targetSnapshot, a.currentRouterState); return o = { ...a, targetRouterState: u } }), ke(a => { this.currentUrlTree = a.urlAfterRedirects, this.rawUrlTree = this.urlHandlingStrategy.merge(a.urlAfterRedirects, a.rawUrl), this.routerState = a.targetRouterState, "deferred" === this.urlUpdateStrategy && (a.extras.skipLocationChange || this.setBrowserUrl(this.rawUrlTree, a), this.browserUrlTree = a.urlAfterRedirects) }), ((e, t, n) => B(r => (new wN(t, r.targetRouterState, r.currentRouterState, n).activate(e), r)))(this.rootContexts, this.routeReuseStrategy, a => this.triggerEvent(a)), ke({ next() { i = !0 }, complete() { i = !0 } }), Hc(() => { i || s || this.cancelNavigationTransition(o, "", 1), this.currentNavigation?.id === o.id && (this.currentNavigation = null) }), bn(a => { if (s = !0, MD(a)) { SD(a) || (this.navigated = !0, this.restoreHistory(o, !0)); const u = new Xs(o.id, this.serializeUrl(o.extractedUrl), a.message, a.cancellationCode); if (r.next(u), SD(a)) { const l = this.urlHandlingStrategy.merge(a.url, this.rawUrlTree), c = { skipLocationChange: o.extras.skipLocationChange, replaceUrl: "eager" === this.urlUpdateStrategy || KD(o.source) }; this.scheduleNavigation(l, "imperative", null, c, { resolve: o.resolve, reject: o.reject, promise: o.promise }) } else o.resolve(!1) } else { this.restoreHistory(o, !0); const u = new mD(o.id, this.serializeUrl(o.extractedUrl), a, o.targetSnapshot ?? void 0); r.next(u); try { o.resolve(this.errorHandler(a)) } catch (l) { o.reject(l) } } return Bt })) })) } resetRootComponentType(n) { this.rootComponentType = n, this.routerState.root.component = this.rootComponentType } setTransition(n) { this.transitions.next({ ...this.transitions.value, ...n }) } initialNavigation() { this.setUpLocationChangeListener(), 0 === this.navigationId && this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 }) } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(n => { const r = "popstate" === n.type ? "popstate" : "hashchange"; "popstate" === r && setTimeout(() => { const o = { replaceUrl: !0 }, i = n.state?.navigationId ? n.state : null; if (i) { const a = { ...i }; delete a.navigationId, delete a.\u0275routerPageId, 0 !== Object.keys(a).length && (o.state = a) } const s = this.parseUrl(n.url); this.scheduleNavigation(s, r, i, o) }, 0) })) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.currentNavigation } triggerEvent(n) { this.events.next(n) } resetConfig(n) { this.config = n.map(id), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.transitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0 } createUrlTree(n, r = {}) { const { relativeTo: o, queryParams: i, fragment: s, queryParamsHandling: a, preserveFragment: u } = r, l = o || this.routerState.root, c = u ? this.currentUrlTree.fragment : s; let d = null; switch (a) { case "merge": d = { ...this.currentUrlTree.queryParams, ...i }; break; case "preserve": d = this.currentUrlTree.queryParams; break; default: d = i || null }return null !== d && (d = this.removeEmptyProps(d)), zR(l, this.currentUrlTree, n, d, c ?? null) } navigateByUrl(n, r = { skipLocationChange: !1 }) { const o = Kn(n) ? n : this.parseUrl(n), i = this.urlHandlingStrategy.merge(o, this.rawUrlTree); return this.scheduleNavigation(i, "imperative", null, r) } navigate(n, r = { skipLocationChange: !1 }) { return function _P(e) { for (let t = 0; t < e.length; t++) { if (null == e[t]) throw new E(4008, false) } }(n), this.navigateByUrl(this.createUrlTree(n, r), r) } serializeUrl(n) { return this.urlSerializer.serialize(n) } parseUrl(n) { let r; try { r = this.urlSerializer.parse(n) } catch (o) { r = this.malformedUriErrorHandler(o, this.urlSerializer, n) } return r } isActive(n, r) { let o; if (o = !0 === r ? { ...DP } : !1 === r ? { ...wP } : r, Kn(n)) return nD(this.currentUrlTree, n, o); const i = this.parseUrl(n); return nD(this.currentUrlTree, i, o) } removeEmptyProps(n) { return Object.keys(n).reduce((r, o) => { const i = n[o]; return null != i && (r[o] = i), r }, {}) } processNavigations() { this.navigations.subscribe(n => { this.navigated = !0, this.lastSuccessfulId = n.id, this.currentPageId = n.targetPageId, this.events.next(new Qn(n.id, this.serializeUrl(n.extractedUrl), this.serializeUrl(this.currentUrlTree))), this.lastSuccessfulNavigation = this.currentNavigation, this.titleStrategy?.updateTitle(this.routerState.snapshot), n.resolve(!0) }, n => { this.console.warn(`Unhandled Navigation Error: ${n}`) }) } scheduleNavigation(n, r, o, i, s) { if (this.disposed) return Promise.resolve(!1); let a, u, l; s ? (a = s.resolve, u = s.reject, l = s.promise) : l = new Promise((f, h) => { a = f, u = h }); const c = ++this.navigationId; let d; return "computed" === this.canceledNavigationResolution ? (0 === this.currentPageId && (o = this.location.getState()), d = o && o.\u0275routerPageId ? o.\u0275routerPageId : i.replaceUrl || i.skipLocationChange ? this.browserPageId ?? 0 : (this.browserPageId ?? 0) + 1) : d = 0, this.setTransition({ id: c, targetPageId: d, source: r, restoredState: o, currentUrlTree: this.currentUrlTree, currentRawUrl: this.rawUrlTree, rawUrl: n, extras: i, resolve: a, reject: u, promise: l, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), l.catch(f => Promise.reject(f)) } setBrowserUrl(n, r) { const o = this.urlSerializer.serialize(n), i = { ...r.extras.state, ...this.generateNgRouterState(r.id, r.targetPageId) }; this.location.isCurrentPathEqualTo(o) || r.extras.replaceUrl ? this.location.replaceState(o, "", i) : this.location.go(o, "", i) } restoreHistory(n, r = !1) { if ("computed" === this.canceledNavigationResolution) { const o = this.currentPageId - n.targetPageId; "popstate" !== n.source && "eager" !== this.urlUpdateStrategy && this.currentUrlTree !== this.currentNavigation?.finalUrl || 0 === o ? this.currentUrlTree === this.currentNavigation?.finalUrl && 0 === o && (this.resetState(n), this.browserUrlTree = n.currentUrlTree, this.resetUrlToCurrentUrlTree()) : this.location.historyGo(o) } else "replace" === this.canceledNavigationResolution && (r && this.resetState(n), this.resetUrlToCurrentUrlTree()) } resetState(n) { this.routerState = n.currentRouterState, this.currentUrlTree = n.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, n.rawUrl) } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } cancelNavigationTransition(n, r, o) { const i = new Xs(n.id, this.serializeUrl(n.extractedUrl), r, o); this.triggerEvent(i), n.resolve(!1) } generateNgRouterState(n, r) { return "computed" === this.canceledNavigationResolution ? { navigationId: n, \u0275routerPageId: r } : { navigationId: n } } } return e.\u0275fac = function (n) { Uu() }, e.\u0275prov = N({ token: e, factory: function () { return qD() }, providedIn: "root" }), e })(); function KD(e) { return "imperative" !== e } class QD { } let IP = (() => { class e { constructor(n, r, o, i, s) { this.router = n, this.injector = o, this.preloadingStrategy = i, this.loader = s } setUpPreloading() { this.subscription = this.router.events.pipe(on(n => n instanceof Qn), Cn(() => this.preload())).subscribe(() => { }) } preload() { return this.processRoutes(this.injector, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(n, r) { const o = []; for (const i of r) { i.providers && !i._injector && (i._injector = ms(i.providers, n, `Route: ${i.path}`)); const s = i._injector ?? n, a = i._loadedInjector ?? s; i.loadChildren && !i._loadedRoutes && void 0 === i.canLoad || i.loadComponent && !i._loadedComponent ? o.push(this.preloadConfig(s, i)) : (i.children || i._loadedRoutes) && o.push(this.processRoutes(a, i.children ?? i._loadedRoutes)) } return ve(o).pipe(Yn()) } preloadConfig(n, r) { return this.preloadingStrategy.preload(r, () => { let o; o = r.loadChildren && void 0 === r.canLoad ? this.loader.loadChildren(n, r) : M(null); const i = o.pipe(Me(s => null === s ? M(void 0) : (r._loadedRoutes = s.routes, r._loadedInjector = s.injector, this.processRoutes(s.injector ?? n, s.routes)))); return r.loadComponent && !r._loadedComponent ? ve([i, this.loader.loadComponent(r)]).pipe(Yn()) : i }) } } return e.\u0275fac = function (n) { return new (n || e)(b(Ae), b(ql), b(pn), b(QD), b(dd)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); const pd = new P(""); let ZD = (() => { class e { constructor(n, r, o = {}) { this.router = n, this.viewportScroller = r, this.options = o, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, o.scrollPositionRestoration = o.scrollPositionRestoration || "disabled", o.anchorScrolling = o.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.router.events.subscribe(n => { n instanceof Qc ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = n.navigationTrigger, this.restoredId = n.restoredState ? n.restoredState.navigationId : 0) : n instanceof Qn && (this.lastId = n.id, this.scheduleScrollEvent(n, this.router.parseUrl(n.urlAfterRedirects).fragment)) }) } consumeScrollEvents() { return this.router.events.subscribe(n => { n instanceof yD && (n.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(n.position) : n.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(n.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(n, r) { this.router.triggerEvent(new yD(n, "popstate" === this.lastSource ? this.store[this.restoredId] : null, r)) } ngOnDestroy() { this.routerEventsSubscription && this.routerEventsSubscription.unsubscribe(), this.scrollEventsSubscription && this.scrollEventsSubscription.unsubscribe() } } return e.\u0275fac = function (n) { Uu() }, e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })(); function Wr(e, t) { return { \u0275kind: e, \u0275providers: t } } function gd(e) { return [{ provide: cd, multi: !0, useValue: e }] } function YD() { const e = ue(lt); return t => { const n = e.get(Es); if (t !== n.components[0]) return; const r = e.get(Ae), o = e.get(XD); 1 === e.get(md) && r.initialNavigation(), e.get(ew, null, A.Optional)?.setUpPreloading(), e.get(pd, null, A.Optional)?.init(), r.resetRootComponentType(n.componentTypes[0]), o.next(), o.complete() } } const XD = new P("", { factory: () => new At }), md = new P("", { providedIn: "root", factory: () => 1 }); const ew = new P(""); function AP(e) { return Wr(0, [{ provide: ew, useExisting: IP }, { provide: QD, useExisting: e }]) } const tw = new P("ROUTER_FORROOT_GUARD"), xP = [lc, { provide: sD, useClass: Uc }, { provide: Ae, useFactory: qD }, ri, { provide: Zn, useFactory: function JD(e) { return e.routerState.root }, deps: [Ae] }, dd]; function RP() { return new wy("Router", Ae) } let nw = (() => { class e { constructor(n) { } static forRoot(n, r) { return { ngModule: e, providers: [xP, [], gd(n), { provide: tw, useFactory: FP, deps: [[Ae, new go, new mo]] }, { provide: la, useValue: r || {} }, r?.useHash ? { provide: Gn, useClass: ST } : { provide: Gn, useClass: Gy }, { provide: pd, useFactory: () => { const e = ue(Ae), t = ue(qA), n = ue(la); return n.scrollOffset && t.setOffset(n.scrollOffset), new ZD(e, t, n) } }, r?.preloadingStrategy ? AP(r.preloadingStrategy).\u0275providers : [], { provide: wy, multi: !0, useFactory: RP }, r?.initialNavigation ? kP(r) : [], [{ provide: rw, useFactory: YD }, { provide: hy, multi: !0, useExisting: rw }]] } } static forChild(n) { return { ngModule: e, providers: [gd(n)] } } } return e.\u0275fac = function (n) { return new (n || e)(b(tw, 8)) }, e.\u0275mod = Gt({ type: e }), e.\u0275inj = Rt({ imports: [rd] }), e })(); function FP(e) { return "guarded" } function kP(e) { return ["disabled" === e.initialNavigation ? Wr(3, [{ provide: ws, multi: !0, useFactory: () => { const t = ue(Ae); return () => { t.setUpLocationChangeListener() } } }, { provide: md, useValue: 2 }]).\u0275providers : [], "enabledBlocking" === e.initialNavigation ? Wr(2, [{ provide: md, useValue: 0 }, { provide: ws, multi: !0, deps: [lt], useFactory: t => { const n = t.get(bT, Promise.resolve()); let r = !1; return () => n.then(() => new Promise(i => { const s = t.get(Ae), a = t.get(XD); (function o(i) { t.get(Ae).events.pipe(on(a => a instanceof Qn || a instanceof Xs || a instanceof mD), B(a => a instanceof Qn || a instanceof Xs && (0 === a.code || 1 === a.code) && null), on(a => null !== a), Qo(1)).subscribe(() => { i() }) })(() => { i(!0), r = !0 }), s.afterPreactivation = () => (i(!0), r || a.closed ? M(void 0) : a), s.initialNavigation() })) } }]).\u0275providers : []] } const rw = new P(""); let jP = (() => { class e { constructor(n) { this.http = n, this.urlRepo = "https://api.github.com/users/Joaoalen98/repos" } getRepos() { return this.http.get(this.urlRepo) } } return e.\u0275fac = function (n) { return new (n || e)(b($v)) }, e.\u0275prov = N({ token: e, factory: e.\u0275fac, providedIn: "root" }), e })(); function VP(e, t) { if (1 & e && (le(0, "article", 24)(1, "a", 25)(2, "h3", 26), dt(3), pe(), le(4, "p"), dt(5), pe(), le(6, "p"), dt(7), pe()()()), 2 & e) { const n = t.$implicit; Vn(1), Dl("href", n.html_url, Bi), Vn(2), ds(n.name), Vn(2), ds(n.description), Vn(2), Ro("Linguagem utilizada: ", n.language, "") } } const $P = [{ path: "", component: (() => { class e { constructor(n) { this.githubServices = n, this.repositorios = [] } ngOnInit() { this.githubServices.getRepos().subscribe(n => this.repositorios = n.filter(r => "Joaoalen98" != r.name)) } } return e.\u0275fac = function (n) { return new (n || e)(I(jP)) }, e.\u0275cmp = xn({ type: e, selectors: [["app-home"]], decls: 34, vars: 1, consts: [[1, "home"], [1, "sobre"], [1, "sobre-titulo"], [1, "sobre-detalhes"], ["src", "assets/images/imagem-perfil.jpeg", "alt", "imagem perfil", 1, "imagem-perfil"], [1, "sobre-detalhes-descricao"], [1, "detalhes-lista"], [1, "detalhes-lista-item"], [1, "detalhes-lista-item", "lista-item-contatos"], ["href", "https://www.linkedin.com/in/jo%C3%A3o-a-a6588b129/", "target", "_blank", 1, "lista-item-contato"], [1, "fa-brands", "fa-linkedin"], ["href", "https://github.com/Joaoalen98", "target", "_blank", 1, "lista-item-contato"], [1, "fa-brands", "fa-github"], ["href", "mailto:joao.alencar1497@gmail.com", "target", "_blank", 1, "lista-item-contato"], [1, "fa-solid", "fa-envelope"], [1, "skills"], [1, "skills-container"], ["src", "https://raw.githubusercontent.com/devicons/devicon/1119b9f84c0290e0f0b38982099a2bd027a48bf1/icons/html5/html5-plain.svg", "alt", "", 1, "skill-icone"], ["src", "https://raw.githubusercontent.com/devicons/devicon/1119b9f84c0290e0f0b38982099a2bd027a48bf1/icons/css3/css3-plain.svg", "alt", "", 1, "skill-icone"], ["src", "https://raw.githubusercontent.com/devicons/devicon/1119b9f84c0290e0f0b38982099a2bd027a48bf1/icons/javascript/javascript-plain.svg", "alt", "", 1, "skill-icone"], ["src", "https://raw.githubusercontent.com/devicons/devicon/1119b9f84c0290e0f0b38982099a2bd027a48bf1/icons/csharp/csharp-plain.svg", "alt", "", 1, "skill-icone"], [1, "projetos"], [1, "projetos-container"], ["class", "projeto", 4, "ngFor", "ngForOf"], [1, "projeto"], ["target", "_blank", 1, "projeto-link", 3, "href"], [1, "titulo-projeto"]], template: function (n, r) { 1 & n && (le(0, "section", 0)(1, "article", 1)(2, "h2", 2), dt(3, "Jo\xe3o Alencar"), pe(), le(4, "div", 3), Ct(5, "img", 4), le(6, "div", 5)(7, "ul", 6)(8, "li", 7), dt(9, " Cursando An\xe1lise e Desenvolvimento de Sistemas (2/5 semestre), na Faculdade Impacta; "), pe(), le(10, "li", 7), dt(11, " Estudando C#: ASP.NET CORE (WepApi, Mvc), Windows Forms, Blazor, Entity Framework; "), pe(), le(12, "li", 7), dt(13, " Interesse em: HTML, CSS Javascript/Typescript, Angular e Flutter; "), pe(), le(14, "li", 8)(15, "a", 9), Ct(16, "i", 10), pe(), le(17, "a", 11), Ct(18, "i", 12), pe(), le(19, "a", 13), Ct(20, "i", 14), pe()()()()()(), le(21, "article", 15)(22, "h2"), dt(23, "Minhas Skills"), pe(), le(24, "div", 16), Ct(25, "img", 17)(26, "img", 18)(27, "img", 19)(28, "img", 20), pe()(), le(29, "article", 21)(30, "h2"), dt(31, "Projetos"), pe(), le(32, "div", 22), function tg(e, t, n, r, o, i, s, a) { const u = v(), l = z(), c = e + 22, d = l.firstCreatePass ? function O0(e, t, n, r, o, i, s, a, u) { const l = t.consts, c = Er(t, e, 4, s || null, cn(l, a)); il(t, n, c, cn(l, u)), Ii(t, c); const d = c.tViews = ol(2, c, r, o, i, t.directiveRegistry, t.pipeRegistry, null, t.schemas, l); return null !== t.queries && (t.queries.template(t, c), d.queries = t.queries.embeddedTView(c)), c }(c, l, u, t, n, r, o, i, s) : l.data[c]; Pt(d, !1); const f = u[V].createComment(""); Ki(l, u, f, d), Pe(f, u), ns(u, u[c] = jp(f, u, f, d)), _i(d) && nl(l, u, d), null != s && rl(u, d, a) }(33, VP, 8, 4, "article", 23), pe()()()), 2 & n && (Vn(33), gl("ngForOf", r.repositorios)) }, dependencies: [ov], styles: [".home[_ngcontent-%COMP%]{padding:20px 5%}.home[_ngcontent-%COMP%]   .sobre-titulo[_ngcontent-%COMP%]{text-align:center;font-size:35px}.home[_ngcontent-%COMP%]   .sobre-detalhes[_ngcontent-%COMP%]{display:flex;justify-content:space-between;align-items:center;padding:20px 0}@media (max-width: 1221px){.home[_ngcontent-%COMP%]   .sobre-detalhes[_ngcontent-%COMP%]{flex-direction:column}}.home[_ngcontent-%COMP%]   .imagem-perfil[_ngcontent-%COMP%]{width:300px;border-radius:50%}@media (max-width: 1221px){.home[_ngcontent-%COMP%]   .imagem-perfil[_ngcontent-%COMP%]{margin-bottom:20px}}.home[_ngcontent-%COMP%]   .lista-item-contatos[_ngcontent-%COMP%]{list-style:none;margin-top:10px}.home[_ngcontent-%COMP%]   .lista-item-contatos[_ngcontent-%COMP%]   .lista-item-contato[_ngcontent-%COMP%]{font-size:30px;color:var(--branco-1);margin-right:10px}.home[_ngcontent-%COMP%]   .lista-item-contatos[_ngcontent-%COMP%]   .lista-item-contato[_ngcontent-%COMP%]:hover{color:var(--cinza-escuro-3);transition:1s all}.home[_ngcontent-%COMP%]   .skills[_ngcontent-%COMP%]   .skills-container[_ngcontent-%COMP%]{display:flex;justify-content:space-between;padding:20px 0}.home[_ngcontent-%COMP%]   .skills[_ngcontent-%COMP%]   .skills-container[_ngcontent-%COMP%]   .skill-icone[_ngcontent-%COMP%]{width:100px}@media (max-width: 600px){.home[_ngcontent-%COMP%]   .skills[_ngcontent-%COMP%]   .skills-container[_ngcontent-%COMP%]   .skill-icone[_ngcontent-%COMP%]{width:50px}}.home[_ngcontent-%COMP%]   .projetos[_ngcontent-%COMP%]{padding:20px 0}.home[_ngcontent-%COMP%]   .projetos[_ngcontent-%COMP%]   .projetos-container[_ngcontent-%COMP%]   .projeto[_ngcontent-%COMP%]{border-radius:20px;background-color:var(--cinza-escuro-1);margin-bottom:10px}.home[_ngcontent-%COMP%]   .projetos[_ngcontent-%COMP%]   .projetos-container[_ngcontent-%COMP%]   .projeto[_ngcontent-%COMP%]   .projeto-link[_ngcontent-%COMP%]{display:block;padding:20px;color:var(--branco-1);text-decoration:none;border-radius:20px}.home[_ngcontent-%COMP%]   .projetos[_ngcontent-%COMP%]   .projetos-container[_ngcontent-%COMP%]   .projeto[_ngcontent-%COMP%]   .projeto-link[_ngcontent-%COMP%]:hover{background-color:var(--cinza-escuro-3);padding-left:30px;transition:1s all}"] }), e.\u0275prov = N({ token: e, factory: e.\u0275fac }), e })() }]; let HP = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = Gt({ type: e }), e.\u0275inj = Rt({ imports: [nw.forRoot($P), nw] }), e })(), BP = (() => { class e { constructor() { } ngOnInit() { } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = xn({ type: e, selectors: [["app-header"]], decls: 3, vars: 0, consts: [[1, "header"]], template: function (n, r) { 1 & n && (le(0, "header", 0)(1, "h1"), dt(2, "Portif\xf3lio"), pe()()) }, styles: [".header[_ngcontent-%COMP%]{display:flex;align-items:center;height:100px;padding:0 5%;background-color:var(--cinza-escuro-1)}"] }), e })(), UP = (() => { class e { constructor() { this.data = (new Date).getUTCFullYear() } ngOnInit() { } } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = xn({ type: e, selectors: [["app-footer"]], decls: 2, vars: 1, consts: [[1, "footer"]], template: function (n, r) { 1 & n && (le(0, "footer", 0), dt(1), pe()), 2 & n && (Vn(1), Ro(" \xa9 - ", r.data, "\n")) }, styles: [".footer[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;height:100px;background-color:var(--cinza-escuro-1)}"] }), e })(), zP = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275cmp = xn({ type: e, selectors: [["app-root"]], decls: 4, vars: 0, consts: [[2, "min-height", "calc(100vh - 200px)"]], template: function (n, r) { 1 & n && (Ct(0, "app-header"), le(1, "main", 0), Ct(2, "router-outlet"), pe(), Ct(3, "app-footer")) }, dependencies: [nd, BP, UP] }), e })(), GP = (() => { class e { } return e.\u0275fac = function (n) { return new (n || e) }, e.\u0275mod = Gt({ type: e, bootstrap: [zP] }), e.\u0275inj = Rt({ imports: [Fx, HP, oR] }), e })(); (function rT() { xy = !1 })(), Ox().bootstrapModule(GP).catch(e => console.error(e)) } }, Y => { Y(Y.s = 778) }]);